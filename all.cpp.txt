#define _CRT_SECURE_NO_WARNINGS
#include "all.h"
#include"string.h"
#include"ctype.h"//字符测试函数isaplha字母测试 isdigit 数字测试 ......
#include"math.h"
/*
识别SNL单词的DFA表示
分为标识符状态INID（字母），数字状态INNUM（数字），完成状态DONE（加减乘除等），赋值状态INASSIGN（=），
注释状态INCOMMENT（{），数组下标下界状态INRANGE（.），字母标志状态INCHAR,开始状态START

*/
typedef enum
{
	INID, INNUM, DONE, INASSIGN, INCOMMENT, INRANGE, INCHAR, START
}StateType;
char tokenword[41];//用于保存标识符保留字
static char line[256];//每行最大所容的长度，一行的字符全部存在这里
static int Line = 0;//在line中当前字符位置
static int linelarge = 0;//在当前缓冲区中存的字符串的大小



int EOF_FLAG = FALSE;//文件末尾标志
int isend = TRUE;//源文件追踪标志

int TraceScan = FALSE;//词法分析追踪标志，将词法分析信息输出到中间文件listing
int getnext()//取下一个非空字符
{

	if (Line >= linelarge)//当前代码输入行缓冲区已经耗尽
	{
		lineno++;
		if (fgets(line, 255, source))//从文件source中读取254个字符
		{
			if (isend)
				fprintf(listing, "%4d: %s", lineno, line);//追踪标志位真，则将行号及行内容在此法扫描时写入listing文件中国呢
			//输入源码的实际行的长度
			linelarge = strlen(line);
			Line = 0;//当前字符位置为0;
			return line[Line++];//去的输入缓冲区的下一个字符
		}
		else
		{
			EOF_FLAG = TRUE;
			return EOF;//已经到源代码文件末尾
		}
	}
	else
	{
		//输入缓冲区中字符未读完，直接取下一个字符
		return line[Line++];
	}

}
void disgetnext()//回退字符，在行缓冲区中回退，超前读字符后不匹配时候的回退
{
	//不是处于文件末尾，输入行缓冲区中当前字符位置减1
	if (!EOF_FLAG)Line--;
}
static struct
{
	char*str;
	WordType wt;
}baoliu[maxbaoliu] = { {(char*)"program",PROGRAM},{(char*)"type",TYPE},{(char*)"var",VAR},{(char*)"procedure",PROCEDURE}
	   ,{(char*)"begin",BEGIN},{(char*)"end",END},{(char*)"array",ARRAY},{(char*)"of",OF},{(char*)"record",RECORD}
	   ,{(char*)"if",IF},{(char*)"then",THEN},{(char*)"else",ELSE},{(char*)"fi",FI},{(char*)"while",WHILE}
	   ,{(char*)"do",DO},{(char*)"endwh",ENDWH},{(char*)"read",READ},{(char*)"write",WRITE},{(char*)"return",RETURN}
	   ,{(char*)"integer",INTEGER},{(char*)"char",CHAR} };

WordType checkbaoliu(char*a)//保留字查找函数
{
	for (int i = 0; i < maxbaoliu; i++)
	{
		if (!strcmp(a, baoliu[i].str))//若匹配
			return baoliu[i].wt;//返回保留字的单词
	}
	//若未在保留字中找到，则为表示符ID
	return ID;
}
ChainNodeType *chainHead;//链表表头
void getToken()//取得单词函数
{

	ChainNodeType *currentNode;//指向处理当前token的当前节点指针
	ChainNodeType *preNode;//指向前驱
	TokenType *currentToken=(TokenType*)malloc(sizeof(TokenType));//存放当前的token
	memset(currentToken->Mean, 0, 41 * sizeof(char));
	chainHead = (ChainNodeType*)malloc(chainnodelenghth);
	preNode = (ChainNodeType*)malloc(chainnodelenghth);
	currentNode = (ChainNodeType*)malloc(chainnodelenghth);
	memset(chainHead->Token.Mean, 0, 41 * sizeof(char));
	memset(preNode->Token.Mean, 0, 41 * sizeof(char));
	memset(currentNode->Token.Mean, 0, 41 * sizeof(char));
	preNode = chainHead;
	currentNode = chainHead;
	//指向下一个节点的指针为空
	(*currentNode).nextToken = NULL;
	//当前正在识别字符位置初始为0
	do {
		int tokenwordid = 0;
		//自动机标志位为开始START
		StateType state = START;
		//tokenword的存储标志save，决定当前识别字符是否存入当前词元存储区tokenword
		int save;
		//当前确定优先自动机状态state不是完成状态DONE
		while (state != DONE)
		{
			int c = getnext();
			save = TRUE;//当前正在识别字符的存储标志
			switch (state)
			{
			case START:
				if (isdigit(c))//当前字符c为数字则设置成数字状态
					state = INNUM;
				else if (isalpha(c))//当前字符c为字模则设置成标识符状态
					state = INID;
				else if (c == ':')//冒号为赋值状态
					state = INASSIGN;
				else if (c == '.')//.为数组下标界限状态
					state = INRANGE;
				else if (c == '\'')//'为字符标志状态
				{
					save = FALSE;
					state = INCHAR;
				}
				else if ((c == ' ') || (c == '\t') || (c == '\n'))//空白（空格，制表符，换行符)无需存储，save为false
					save = FALSE;
				else if (c == '{')//左括号注释状态，表示产生注释无需存储
				{
					save = FALSE;
					state = INCOMMENT;
				}
				else//否则为完成状态，进一步分类处理自动机结束位置
				{
					state = DONE;
					switch (c)
					{
					case EOF:
						save = FALSE;
						currentToken->Word = ENDFILE;
						break;
					case '=':
						currentToken->Word = EQ;
						break;
					case '<':
						currentToken->Word = LT;
						break;
					case '+':
						currentToken->Word = PLUS;
						break;
					case '-':
						currentToken->Word = MINUS;
						break;
					case '*':
						currentToken->Word = TIMES;
						break;
					case '/':
						currentToken->Word = OVER;
						break;
					case '(':
						currentToken->Word = LPAREN;
						break;
					case ')':
						currentToken->Word = RPAREN;
						break;
					case ';':
						currentToken->Word = SEMI;
						break;
					case ',':
						currentToken->Word = COMMA;
						break;
					case '[':
						currentToken->Word = LMIDPAREN;
						break;
					case ']':
						currentToken->Word = RMIDPAREN;
						break;
					default:
						currentToken->Word = ERROR;
						Error = TRUE;
						break;
					}
				}
				break;
			case INCOMMENT://注释状态
				if (c == EOF)
				{
					state = DONE;//若为EOF则当前DFA状态设置为完成状态
					currentToken->Word = ENDFILE;
				}
				else if (c == '}')//注释结束
				{
					state = START;
					save = FALSE;
				}
				else
					save = FALSE;
				break;
			case INASSIGN://赋值状态
				state = DONE;
				if (c == '=')
					currentToken->Word = ASSIGN;
				else//：后面不是=则回退一个字符
				{
					disgetnext();
					save = FALSE;
					currentToken->Word = ERROR;
					Error = TRUE;
				}
				break;
			case INRANGE:
				state = DONE;
				if (c == '.')
					currentToken->Word = UNDERANGE;
				else
				{
					disgetnext();
					save = FALSE;
					currentToken->Word = DOT;
				}
				break;
			case INNUM:
				if (!isdigit(c))//如果字符c不是数则回退存储为false。
				{
					disgetnext();
					save = FALSE;
					state = DONE;
					currentToken->Word = INTC;//数字单词
				}
				break;
			case INCHAR:
				if (isalnum(c))
				{
					int c1 = getnext();
					if (c1 == '\'')
					{
						save = TRUE;
						state = DONE;
						currentToken->Word = CHARC;
					}
					else
					{
						disgetnext();
						disgetnext();
						state = DONE;
						currentToken->Word = ERROR;
						Error = TRUE;

					}
				}
				else
				{
					disgetnext();
					state = DONE;
					currentToken->Word = ERROR;
					Error = TRUE;

				}
				break;
			case INID:
				if (!isalnum(c))//不是字母回退一格
				{
					disgetnext();
					save = FALSE;
					state = DONE;
					currentToken->Word = ID;//标识符单词
				}
				break;
			case DONE://确定性优先自动机处于单词结束位置
				break;
			default:
				//词法扫描器产生错误的状态state写入列表文件listing
				fprintf(listing, "First Bug: state= %d\n", state);
				Error = TRUE;
				state = DONE;
				currentToken->Word = ERROR;
				break;
			}
			//当前字符存储状态为ture，且当前单词已经识别部分未超过单词最大长度
			//将当前字符写入当前正在识别单词存储区tokenword
			if ((save) && (tokenwordid <= maxtokenlenhth))
				tokenword[tokenwordid++] = (char)c;
			if (state == DONE)
			{
				//当前DFA识别完成在当前存储区加上结束标志
				tokenword[tokenwordid] = '\0';
				if (currentToken->Word == ID)//如果为标识符单词类型查看是否为保留字单词
				{
					currentToken->Word = checkbaoliu(tokenword);
					if (currentToken->Word == ID)
						strcpy(tokenword, tokenword);
				}
			}
		}

		currentToken->lineshow = lineno;//行号信息
		strcpy(currentToken->Mean, tokenword);
		//将已经处理完的token存入链表的token部分
		((*currentNode).Token).lineshow = currentToken->lineshow;
		((*currentNode).Token).Word = currentToken->Word;
		strcpy(((*currentNode).Token).Mean, currentToken->Mean);
		Tokennum++;//总数目加一
		//若不是第一个节点则将当前节点连入链表
		if (preNode != currentNode)
		{
			preNode->nextToken = currentNode;
			preNode = currentNode;
		}
		//申请一个新的节点记录下一个Token信息
		currentNode = (ChainNodeType*)malloc(chainnodelenghth);
		memset(currentNode->Token.Mean, 0, 41 * sizeof(char));
		currentNode->nextToken = NULL;
	} while ((currentToken->Word) != ENDFILE);
	//将由chainhead指向的token链表存入文件tokenlist中
	ChainToFile(chainHead);
}




/**************************************************************/
//                           语法分析                           //
/***************************************************************/

char *tempname;
static TreeNode*parse();//语法分析函数
static TreeNode*Program();//总程序
static TreeNode*ProgramHead();//程序头
static TreeNode*DeclarePart();//程序声明
static TreeNode*TypeDec();//类型声明
static TreeNode*TypeDeclaration();
static TreeNode*TypeDecList();
static TreeNode*TypeDecMore();
static void TypeId(TreeNode*t);
static void BaseType(TreeNode*t);
static void StructureType(TreeNode*t);
static void ArrayType(TreeNode*t);
static void RecType(TreeNode*t);
static TreeNode*FieldDecList();
static TreeNode*FieldDecMore();
static void IdList(TreeNode*t);
static void IdMore(TreeNode*t);
static void TypeName(TreeNode*t);//类型名
static TreeNode*VarDec();//变量声明
static TreeNode*VarDeclaration();
static TreeNode*VarDecList();
static TreeNode*VarDecMore();
static void VarIdList(TreeNode*t);
static void VarIdMore(TreeNode*t);
static TreeNode*ProDec();//过程声明
static TreeNode*ProDeclaration();
static void ParamList(TreeNode*t);//参数声明
static TreeNode*ParamDecList();
static TreeNode*Param();
static TreeNode*ParamMore();
static void FormList(TreeNode*t);
static void FidMore(TreeNode*t);
static TreeNode*ProcDecPart();//过程中的声明
static TreeNode*ProcBody();//过程体
static TreeNode*ProgramBody();
static TreeNode*StmList();//语句序列
static TreeNode*StmMore();
static TreeNode*Stm();//语句
static TreeNode*AssCall();
static TreeNode*AssignmentRest();
static TreeNode*ConditionalStm();
static TreeNode*LoopStm();
static TreeNode*InputStm();
static TreeNode*OutputStm();
static TreeNode*ReturnStm();
static TreeNode*CallStmRest();
static TreeNode*ActParamList();
static TreeNode*ActParamMore();
static TreeNode*Exception();//表达式
static TreeNode*simple_exp();//简单表达式
static TreeNode*term();//项
static TreeNode*factor();//因子
static TreeNode*variable();
static void  VariMore(TreeNode*t);
static TreeNode*FieldVar();
static void FieldVarMore(TreeNode*t);


// 函数名 syntaxError												
// 功  能 语法错误处理函数											
// 说  明 将函数参数message指定的错误信息格式化写入列表文件listing	
//	  设置错误追踪标志Error为TRUE								

static void syntaxError(const char * message)

{
	fprintf(listing, "\n>>> error :   ");
	fprintf(listing, "Syntax error at line %d: %s\n", token.lineshow, message);
	Error = TRUE;
}

//总程序处理分析程序
//产生式：< Program  > ::= ProgramHead DeclarePart ProgramBody
//根据产生式生成语法树的根节点，调用程序头部的分析函数，声明部分分析函数，程序体部分分析函数，分别为语法树的三个儿子节点，
//匹配程序结束标志.（DOT）如果处理成功返回root否则返回null
TreeNode*Program()
{
	TreeNode*t = ProgramHead();
	TreeNode*q = DeclarePart();
	TreeNode*s = ProcBody();//三个儿子节点
	TreeNode*root = newroot();
	if (root != NULL)
	{
		root->treechild[0] = t;
		root->treechild[1] = q;
		root->treechild[2] = s;
	}
	match(DOT);
	return root;
}
//程序头处理函数
//产生式 < programHead > ::= PROGRAM  ProgramName
//分局根据产生式调用相应的递归处理函数
TreeNode*ProgramHead()
{
	TreeNode*t = newProhead();
	match(PROGRAM);
	if ((t != NULL) && (token.Word == ID))
	{
		t->noline = linelinshi;
		strcpy(t->name[0], token.Mean);
	}
	match(ID);
	return t;
}
//声明部分处理函数
//产生式：< declarePart > ::= typeDec  varDec  procDec
//函数根据文法产生式调用相应的递归处理函数
TreeNode*DeclarePart()
{
	TreeNode * typeP = newTypeNode();
	TreeNode * pp = typeP;

	if (typeP != NULL)
	{
		typeP->noline = linelinshi;
		TreeNode * tp1 = TypeDec();
		if (tp1 != NULL)
			typeP->treechild[0] = tp1;
		else
		{
			free(typeP);
			typeP = NULL;
		}
	}
	/*变量*/
	TreeNode * varP = newDecANode(Var);
	if (varP != NULL)
	{
		varP->noline = linelinshi;
		TreeNode * tp2 = VarDec();
		if (tp2 != NULL)
			varP->treechild[0] = tp2;
		else
		{
			free(varP);
			varP = NULL;
		}
	}
	/*函数*/
	TreeNode * s = ProDec();

	if (s == NULL) {}

	if (varP == NULL) { varP = s; }

	if (typeP == NULL) { pp = typeP = varP; }

	if (typeP != varP)
	{
		typeP->brother = varP;
		typeP = varP;
	}
	if (varP != s)
	{
		varP->brother = s;
		varP = s;
	}
	return pp;
}
// 函数名 varDec		 						     	            
// 功  能 变量声明部分的处理函数						        	
// 产生式 < varDec > ::=  ε |  varDeclaration                      
// 函数根据文法产生式,调用相应的递归处理函数,生成语法树节点  

TreeNode*VarDec()
{
	TreeNode * t = NULL;
	switch (token.Word)
	{
	case PROCEDURE:
	case BEGIN:     break;
	case VAR:
		t = VarDeclaration();
		break;
	default:
		ReadNextToken(&token);
		syntaxError("unexpected token is here!");
		break;
	}
	return t;
}
// 函数名 varDeclaration		 						            
// 功  能 变量声明部分的处理函数						        
// 产生式 < varDeclaration > ::=  VAR  varDecList                 
// 说  明 函数根据文法产生式,调用相应的递归处理函数,生成语法树节点  	
TreeNode*VarDeclaration()
{


	match(VAR);
	TreeNode * t = VarDecList();
	if (t == NULL)
		syntaxError("a var declaration is expected!");
	return t;

}
/* 函数名 varDecList		 						                */
/* 功  能 变量声明部分的处理函数						        	*/
/* 产生式 < varDecList > ::=  typeName varIdList; varDecMore        */
/* 说  明 函数根据文法产生式,调用相应的递归处理函数,生成语法树节点  */
/********************************************************************/
TreeNode * VarDecList()
{
	TreeNode * t = newDecNode();
	TreeNode * p = NULL;

	if (t != NULL)
	{
		t->noline = linelinshi;
		TypeName(t);
		VarIdList(t);
		match(SEMI);
		p = VarDecMore();
		t->brother = p;
	}
	return t;
}
//函数名 varDecMore		 						                
// 功  能 变量声明部分的处理函数						        	
// 产生式 < varDecMore > ::=  ε |  varDecList                      
// 说  明 函数根据文法产生式,调用相应的递归处理函数,生成语法树节点  
TreeNode * VarDecMore()
{
	TreeNode * t = NULL;

	switch (token.Word)
	{
	case PROCEDURE:
	case BEGIN:
		break;
	case INTEGER:
	case CHAR:
	case ARRAY:
	case RECORD:
	case ID:
		t = VarDecList();
		break;
	default:
		ReadNextToken(&token);
		syntaxError("unexpected token is here!");
		break;
	}
	return t;
}
// 函数名 typeName		 							  	            
// 功  能 类型声明部分的处理函数						        	
// 产生式 < typeName > ::= baseType | structureType | id            
// 说  明 函数根据文法产生式,调用相应的递归处理函数,生成语法树节点  
void TypeName(TreeNode * t)
{
	if (t != NULL)
		switch (token.Word)
		{
		case INTEGER:
		case CHAR:    BaseType(t); break;
		case ARRAY:
		case RECORD:  StructureType(t); break;
		case ID:
			t->kind.dec = Id;
			strcpy(t->Figure.typeName, token.Mean);
			match(ID);
			break;
		default:
			ReadNextToken(&token);
			syntaxError("unexpected token is here!");
			break;
		}
}
// 函数名 structureType		 							            
// 功  能 类型声明部分的处理函数						        	
// 产生式 < structureType > ::=  arrayType | recType                
// 说  明 函数根据文法产生式,调用相应的递归处理函数,生成语法树节点  
void StructureType(TreeNode * t)
{
	switch (token.Word)
	{
	case ARRAY:
		ArrayType(t);
		break;
	case RECORD:
		t->kind.dec = Record;
		RecType(t);
		break;
	default:
		ReadNextToken(&token);
		syntaxError("unexpected token is here!");
		break;
	}
}

// 功  能 类型声明部分的处理函数						        	
// 产生式 < arrayType > ::=  ARRAY [low..top] OF baseType           
// 说  明 函数根据文法产生式,调用相应的递归处理函数,生成语法树节点  
void ArrayType(TreeNode * t)
{
	match(ARRAY);
	match(LMIDPAREN);
	if (token.Word == INTC)
	{
		t->Figure.ArrayFigure.low = atoi(token.Mean);
	}
	match(INTC);
	match(UNDERANGE);
	if (token.Word == INTC)
	{
		t->Figure.ArrayFigure.up = atoi(token.Mean);
	}
	match(INTC);
	match(RMIDPAREN);
	match(OF);
	BaseType(t);
	t->Figure.ArrayFigure.childtype = t->kind.dec;
	t->kind.dec = Array;
}
// 函数名 procBody		 			  	                           
// 功  能 函数体部分的处理函数	                    	        	
// 产生式 < procBody > ::=  programBody                            
// 说  明 函数根据文法产生式,调用相应的递归处理函数,生成语法树节点  
TreeNode * ProcBody(void)
{
	TreeNode * t = ProgramBody();
	if (t == NULL)
		syntaxError("a program body is requested!");
	return t;
}
// 功  能 程序体部分的处理函数	                    	        	
// 产生式 < programBody > ::=  BEGIN  stmList   END                 
// 说  明 函数根据文法产生式,调用相应的递归处理函数,生成语法树节点  

TreeNode* ProgramBody()
{
	TreeNode * t = newSentenceBiaozhiNode();
	match(BEGIN);
	if (t != NULL)
	{
		t->noline = linelinshi;
		t->treechild[0] = StmList();
	}
	match(END);
	return t;
}
// 功  能 函数声明部分的处理函数						        	
// 产生式 < procDec > ::=  ε |  procDeclaration                    
// 说  明 函数根据文法产生式,调用相应的递归处理函数,生成语法树节点  
TreeNode * ProcDec(void)
{
	TreeNode * t = NULL;
	switch (token.Word)
	{
	case BEGIN:   break;
	case PROCEDURE:
		t = ProDeclaration();
		break;
	default:
		ReadNextToken(&token);
		syntaxError("unexpected token is here!");
		break;
	}
	return t;
}
// 功  能 函数声明部分的处理函数						        	
// 产生式 < procDeclaration > ::=  PROCEDURE                        
//                                 ProcName(paramList);             
//                                 procDecPart                      
//                                 procBody                         
//                                 procDec                          
//说  明 函数根据文法产生式,调用相应的递归处理函数,生成语法树节点  
//        函数的根节点用于记录该函数的名字；第一个子节点指向参数节  
//        点，第二个节点指向函数中的声明部分节点；第三个节点指向函  
//       数体。
TreeNode * ProDeclaration()
{
	TreeNode * t = newProcNode();
	match(PROCEDURE);
	if (t != NULL)
	{
		t->noline = linelinshi;
		if (token.Word == ID)
		{
			strcpy(t->name[0], token.Mean);
			(t->samenum)++;
			match(ID);
		}
		match(LPAREN);
		ParamList(t);
		match(RPAREN);
		match(SEMI);
		t->treechild[1] = ProcDecPart();
		t->treechild[2] = ProcBody();
		t->brother = ProcDec();
	}
	return t;
}

// 功  能 函数中的声明部分的处理函数	             	        	
// 产生式 < procDecPart > ::=  declarePart                          
// 说  明 函数根据文法产生式,调用相应的递归处理函数,生成语法树节点  
TreeNode * ProcDecPart(void)
{
	TreeNode * t = DeclarePart();
	return t;
}
// 功  能 函数声明中参数声明部分的处理函数	        	        	
// 产生式 < paramList > ::=  ε |  paramDecList                     
//说  明 函数根据文法产生式,调用相应的递归处理函数,生成语法树节点  
void ParamList(TreeNode * t)
{
	TreeNode * p = NULL;

	switch (token.Word)
	{
	case RPAREN:  break;
	case INTEGER:
	case CHAR:
	case ARRAY:
	case RECORD:
	case ID:
	case VAR:
		p = ParamDecList();
		t->treechild[0] = p;
		break;
	default:
		ReadNextToken(&token);
		syntaxError("unexpected token is here!");
		break;
	}
}
//功  能 函数声明中参数声明部分的处理函数	        	        	
// 产生式 < paramDecList > ::=  param  paramMore                    
// 说  明 函数根据文法产生式,调用相应的递归处理函数,生成语法树节点  
TreeNode * ParamDecList()
{
	TreeNode * t = Param();
	TreeNode * p = ParamMore();
	if (p != NULL)
	{
		t->brother = p;
	}
	return t;
}
//功  能 函数声明中参数声明部分的处理函数	        	        	
// 产生式 < param > ::=  typeName formList | VAR typeName formList  
// 说  明 函数根据文法产生式,调用相应的递归处理函数,生成语法树节点  
TreeNode * Param()
{
	TreeNode * t = newDecNode();
	if (t != NULL)
	{
		t->noline = linelinshi;
		switch (token.Word)
		{
		case INTEGER:
		case CHAR:
		case ARRAY:
		case RECORD:
		case ID:
			t->Figure.ProcFigure.paramtype = Val;
			TypeName(t);
			FormList(t);
			break;
		case VAR:
			match(VAR);
			t->Figure.ProcFigure.paramtype = Varpa;
			TypeName(t);
			FormList(t);
			break;
		default:
			ReadNextToken(&token);
			syntaxError("unexpected token is here!");
			break;
		}
	}
	return t;
}
//功  能 函数声明部分的处理函数						        	
// 产生式 < procDec > ::=  ε |  procDeclaration                    
// 说  明 函数根据文法产生式,调用相应的递归处理函数,生成语法树节点  
TreeNode * ProDec()
{
	TreeNode * t = NULL;
	switch (token.Word)
	{
	case BEGIN:   break;
	case PROCEDURE:
		t = ProDeclaration();
		break;
	default:
		ReadNextToken(&token);
		syntaxError("unexpected token is here!");
		break;
	}
	return t;
}
//功  能 类型声明部分的处理函数						        	
// 产生式 < baseType > ::=  INTEGER | CHAR                          
// 说  明 函数根据文法产生式,调用相应的递归处理函数,生成语法树节点  
void BaseType(TreeNode * t)
{
	switch (token.Word)
	{
	case INTEGER:  match(INTEGER);
		t->kind.dec = Integer;
		break;

	case CHAR:     match(CHAR);
		t->kind.dec = Char;
		break;

	default:
		ReadNextToken(&token);
		syntaxError("unexpected token is here!");
		break;
	}
}
//功  能 类型声明部分的处理函数						        	
// 产生式 < recType > ::=  RECORD fieldDecList END                  
// 说  明 函数根据文法产生式,调用相应的递归处理函数,生成语法树节点  
void RecType(TreeNode * t)
{
	TreeNode * p = NULL;
	match(RECORD);
	p = FieldDecList();
	if (p != NULL)
		t->treechild[0] = p;
	else
		syntaxError("a record body is requested!");
	match(END);
}
// 功  能 类型声明部分的处理函数						        	
//产生式 < fieldDecList > ::=   baseType idList ; fieldDecMore     
//                             | arrayType idList; fieldDecMore    
//说  明 函数根据文法产生式,调用相应的递归处理函数,生成语法树节点   
TreeNode * FieldDecList()
{

	TreeNode * t = newDecNode();
	TreeNode * p = NULL;
	if (t != NULL)
	{
		t->noline = linelinshi;
		switch (token.Word)
		{
		case INTEGER:
		case CHAR:
			BaseType(t);
			IdList(t);
			match(SEMI);
			p = FieldDecMore();
			break;
		case ARRAY:
			ArrayType(t);
			IdList(t);
			match(SEMI);
			p = FieldDecMore();
			break;
		default:
			ReadNextToken(&token);
			syntaxError("unexpected token is here!");
			break;
		}
		t->brother = p;
	}
	return t;
}
//功  能 类型声明部分的处理函数						        	
//产生式 < fieldDecMore > ::=  ε | fieldDecList                   
//说  明 函数根据文法产生式,调用相应的递归处理函数,生成语法树节点   
TreeNode * FieldDecMore()
{
	TreeNode * t = NULL;
	switch (token.Word)
	{
	case END: break;
	case INTEGER:
	case CHAR:
	case ARRAY:
		t = FieldDecList();
		break;
	default:
		ReadNextToken(&token);
		syntaxError("unexpected token is here!");
		break;
	}
	return t;
}
// 功  能 类型声明部分的处理函数						        	
// 产生式 < idList > ::=  id  idMore                                
//说  明 函数根据文法产生式,调用相应的递归处理函数,生成语法树节点  
void IdList(TreeNode * t)
{
	if (token.Word == ID)
	{
		strcpy(t->name[(t->samenum)], token.Mean);
		match(ID);
		t->samenum = (t->samenum) + 1;
	}
	IdMore(t);
}
// 功  能 类型声明部分的处理函数						        	
// 产生式 < idMore > ::=  ε |  , idList                            
//说  明 函数根据文法产生式,调用相应的递归处理函数,生成语法树节点  
void IdMore(TreeNode * t)
{
	switch (token.Word)
	{
	case SEMI:  break;
	case COMMA:
		match(COMMA);
		IdList(t);
		break;
	default:
		ReadNextToken(&token);
		syntaxError("unexpected token is here!");
		break;
	}
}
// 功  能 类型声明部分的处理函数						        	
// 产生式 < typeDec > ::= ε | TypeDeclaration                      
// 说  明 函数根据文法产生式,调用相应的递归处理函数,生成语法树节点  
TreeNode * TypeDec()
{
	TreeNode * t = NULL;
	switch (token.Word)
	{
	case TYPE: t = TypeDeclaration(); break;
	case VAR:
	case PROCEDURE:
	case BEGIN: break;
	default:
		ReadNextToken(&token);
		syntaxError("unexpected token is here!");
		break;
	}
	return t;
}
// 功  能 类型声明部分的处理函数						        	
// 产生式 < TypeDeclaration > ::= TYPE  TypeDecList                 
// 说  明 函数根据文法产生式,调用相应的递归处理函数,生成语法树节点  
TreeNode * TypeDeclaration()
{
	match(TYPE);
	TreeNode * t = TypeDecList();
	if (t == NULL)
	{
		syntaxError("a type declaration is expected!");
	}
	return t;
}
// 功  能 类型声明部分的处理函数						        	
// 产生式 < TypeDecList > ::= typeId = typeName ; typeDecMore       
// 说  明 函数根据文法产生式,调用相应的递归处理函数,生成语法树节点  
TreeNode * TypeDecList()
{
	TreeNode * t = newDecNode();
	if (t != NULL)
	{
		t->noline = linelinshi;
		TypeId(t);
		match(EQ);
		TypeName(t);
		match(SEMI);
		TreeNode * p = TypeDecMore();
		if (p != NULL)
			t->brother = p;
	}
	return t;
}
// 功  能 类型声明部分的处理函数						        	
// 产生式 < typeDecMore > ::=    ε | TypeDecList                   
// 说  明 函数根据文法产生式,调用相应的递归处理函数,生成语法树节点  
TreeNode *  TypeDecMore()
{
	TreeNode * t = NULL;
	switch (token.Word)
	{
	case VAR:
	case PROCEDURE:
	case BEGIN:
		break;
	case ID:
		t = TypeDecList();
		break;
	default:
		ReadNextToken(&token);
		syntaxError("unexpected token is here!");
		break;
	}
	return t;
}
// 功  能 类型声明部分的处理函数						        	
//产生式 < typeId > ::= id                                         
// 说  明 函数根据文法产生式,调用相应的递归处理函数,生成语法树节点  
void TypeId(TreeNode * t)
{
	int tnum = (t->samenum);
	if ((token.Word == ID) && (t != NULL))
	{
		strcpy(t->name[tnum], token.Mean);
		tnum = tnum + 1;
	}
	t->samenum = tnum;
	match(ID);
}
// 功  能 变量声明部分的处理函数						        	
// 产生式 < varIdList > ::=  id  varIdMore                         
// 说  明 函数根据文法产生式,调用相应的递归处理函数,生成语法树节点  
void VarIdList(TreeNode * t)
{
	if (token.Word == ID)
	{
		strcpy(t->name[(t->samenum)], token.Mean);
		match(ID);
		t->samenum = (t->samenum) + 1;
	}
	else
	{
		syntaxError("a varid is expected here!");
		ReadNextToken(&token);
	}
	VarIdMore(t);
}
// 功  能 变量声明部分的处理函数						        	
// 产生式 < varIdMore > ::=  ε |  , varIdList                      
// 说  明 函数根据文法产生式,调用相应的递归处理函数,生成语法树节点  
void VarIdMore(TreeNode * t)
{
	switch (token.Word)
	{
	case SEMI:  break;
	case COMMA:
		match(COMMA);
		VarIdList(t);
		break;
	default:
		ReadNextToken(&token);
		syntaxError("unexpected token is here!");
		break;
	}
}
// 功  能 函数声明中参数声明部分的处理函数	        	        	
// 产生式 < paramMore > ::=  ε | ; paramDecList                     
//说  明 函数根据文法产生式,调用相应的递归处理函数,生成语法树节点  
TreeNode * ParamMore()
{
	TreeNode * t = NULL;
	switch (token.Word)
	{
	case RPAREN:   break;
	case SEMI:
		match(SEMI);
		t = ParamDecList();
		if (t == NULL)
			syntaxError("a param declaration is request!");
		break;
	default:
		ReadNextToken(&token);
		syntaxError("unexpected token is here!");
		break;
	}
	return t;
}

// 功  能 语句部分的处理函数	                    	        	
// 产生式 < stmList > ::=  stm    stmMore                           
// 说  明 函数根据文法产生式,调用相应的递归处理函数,生成语法树节点  
TreeNode * StmList()
{
	TreeNode * t = Stm();
	TreeNode * p = StmMore();
	if (t != NULL)
		if (p != NULL)
			t->brother = p;
	return t;
}
// 功  能 语句部分的处理函数	                    	        	
// 产生式 < stmMore > ::=   ε |  ; stmList                         
// 说  明 函数根据文法产生式,调用相应的递归处理函数,生成语法树节点  

TreeNode * StmMore()
{
	TreeNode * t = NULL;
	switch (token.Word)
	{
	case ELSE:
	case FI:
	case END:
	case ENDWH:	break;
	case SEMI:
		match(SEMI);
		t = StmList();
		break;
	default:
		ReadNextToken(&token);
		syntaxError("unexpected token is here!");
		break;
	}
	return t;
}
// 功  能 语句部分的处理函数	                    	        	
// 产生式 < stm > ::=   conditionalStm   {IF}                       
//                    | loopStm          {WHILE}                    
//                    | inputStm         {READ}                     
//                    | outputStm        {WRITE}                    
//                    | returnStm        {RETURN}                   
//                    | id  assCall      {id}                       
//说  明 函数根据文法产生式,调用相应的递归处理函数,生成语法树节点  
TreeNode * Stm()
{

	TreeNode * t = NULL;
	switch (token.Word)
	{
	case IF:
		t = ConditionalStm();
		break;
	case WHILE:
		t = LoopStm();
		break;
	case READ:
		t = InputStm();
		break;
	case WRITE:
		t = OutputStm();
		break;
	case RETURN:
		t = ReturnStm();
		break;
	case ID:
		tempname = CopyString(token.Mean);
		match(ID);
		t = AssCall();
		break;
	default:
		ReadNextToken(&token);
		syntaxError("unexpected token is here!");
		break;
	}
	return t;
}
//功  能 循环语句部分的处理函数	                    	        
//产生式 < loopStm > ::=      WHILE exp DO stmList ENDWH           
// 说  明 函数根据文法产生式,调用相应的递归处理函数,生成语法树节点  
TreeNode * LoopStm()
{
	TreeNode * t = newSentenceNode(While);
	match(WHILE);
	if (t != NULL)
	{
		t->noline = linelinshi;
		t->treechild[0] = Exception();
		match(DO);
		t->treechild[1] = StmList();
		match(ENDWH);
	}
	return t;
}

// 功  能 条件语句部分的处理函数	                    	        
// 产生式 < conditionalStm > ::= IF exp THEN stmList ELSE stmList FI
// 说  明 函数根据文法产生式,调用相应的递归处理函数,生成语法树节点  
TreeNode * ConditionalStm()
{
	TreeNode * t = newSentenceNode(If);
	match(IF);
	if (t != NULL)
	{
		t->noline = linelinshi;
		t->treechild[0] = Exception();
	}
	match(THEN);
	if (t != NULL)  t->treechild[1] = StmList();
	if (token.Word == ELSE)
	{
		match(ELSE);
		if (t != NULL)
			t->treechild[2] = StmList();
	}
	match(FI);
	return t;
}
// 功  能 语句部分的处理函数	                    	        	
//产生式 < assCall > ::=   assignmentRest   {:=,LMIDPAREN,DOT}     
//                       | callStmRest      {(}                    
// 说  明 函数根据文法产生式,调用相应的递归处理函数,生成语法树节点  
TreeNode * AssCall()
{
	TreeNode * t = NULL;
	switch (token.Word)
	{
	case ASSIGN:
	case LMIDPAREN:
	case DOT:
		t = AssignmentRest();
		break;
	case LPAREN:
		t = CallStmRest();
		break;
	default:
		ReadNextToken(&token);
		syntaxError("unexpected token is here!");
		break;
	}
	return t;
}
// 功  能 函数调用语句部分的处理函数	                  	        
// 产生式 < callStmRest > ::=  (actParamList)                       
// 说  明 函数根据文法产生式,调用相应的递归处理函数,生成语法树节点  
TreeNode * CallStmRest()
{
	TreeNode * t = newSentenceNode(Call);
	match(LPAREN);
	/*函数调用时，其子节点指向实参*/
	if (t != NULL)
	{
		t->noline = linelinshi;

		/*函数名的结点也用表达式类型结点*/
		TreeNode * child0 = newExpNode(VarType);
		if (child0 != NULL)
		{
			child0->noline = linelinshi;
			strcpy(child0->name[0], tempname);
			(child0->samenum)++;
			t->treechild[0] = child0;
		}
		t->treechild[1] = ActParamList();
	}
	match(RPAREN);
	return t;
}
// 功  能 函数调用实参部分的处理函数	                	        
// 产生式 < actParamList > ::=     ε |  exp actParamMore           
// 说  明 函数根据文法产生式,调用相应的递归处理函数,生成语法树节点  
TreeNode * ActParamList()
{
	TreeNode * t = NULL;

	switch (token.Word)
	{
	case RPAREN:        break;
	case ID:
	case INTC:
		t = Exception();
		if (t != NULL)
			t->brother = ActParamMore();
		break;
	default:
		ReadNextToken(&token);
		syntaxError("unexpected token is here!");
		break;
	}
	return t;
}
// 功  能 函数调用实参部分的处理函数	                	        
// 产生式 < actParamMore > ::=     ε |  , actParamList             
// 说  明 函数根据文法产生式,调用相应的递归处理函数,生成语法树节点  
TreeNode * ActParamMore()
{
	TreeNode * t = NULL;
	switch (token.Word)
	{
	case RPAREN:   break;
	case COMMA:
		match(COMMA);
		t = ActParamList();
		break;
	default:
		ReadNextToken(&token);
		syntaxError("unexpected token is here!");
		break;
	}
	return t;
}
// 功  能 输出语句部分的处理函数	                    	        
// 产生式 < outputStm > ::=   WRITE(exp)                            
// 说  明 函数根据文法产生式,调用相应的递归处理函数,生成语法树节点  
TreeNode * OutputStm()
{
	TreeNode * t = newSentenceNode(Write);
	match(WRITE);
	match(LPAREN);
	if (t != NULL)
	{
		t->noline = linelinshi;
		t->treechild[0] = Exception();
	}
	match(RPAREN);
	return t;
}
// 功  能 表达式处理函数													
// 产生式 < 表达式 > ::= < 简单表达式 > [< 关系运算符 > < 简单表达式 > ]	
// 说  明 该函数根据产生式调用相应递归处理函数,生成表达式类型语法树节点		
TreeNode * Exception()

{
	/* 调用简单表达式处理函数simple_exp(),返回语法树节点指针给t */
	TreeNode * t = simple_exp();

	/* 当前单词token为逻辑运算单词LT或者EQ */
	if ((token.Word == LT) || (token.Word == EQ))
	{
		/* 创建新的OpK类型语法树节点，新语法树节点指针赋给p */
		TreeNode * p = newExpNode(Op);

		/* 新语法树节点p创建成功,初始化p第一个子节点成员child[0]
		 * 并将当前单词token(为EQ或者LT)赋给语法树节点p的运算符成员attr.op*/
		if (p != NULL)
		{
			p->noline = linelinshi;
			p->treechild[0] = t;
			p->Figure.ExceptionFigure.op = token.Word;

			/* 将新的表达式类型语法树节点p作为函数返回值t */
			t = p;
		}

		/* 当前单词token与指定逻辑运算符单词(为EQ或者LT)匹配 */
		match(token.Word);

		/* 语法树节点t非空,调用简单表达式处理函数simple_exp()	*
		 * 函数返回语法树节点指针给t的第二子节点成员child[1]	*/
		if (t != NULL)
			t->treechild[1] = simple_exp();
	}

	/* 函数返回表达式类型语法树节点t */
	return t;
}
//功  能 简单表达式处理函数											
// 产生式 < 简单表达式 >::=	< 项 > { < 加法运算符 > < 项 > }			
// 说  明 该函数根据产生式调用相应递归处理函数,生成表达式类型语法树节点	
TreeNode * simple_exp()

{
	/* 调用元处理函数term(),函数返回语法树节点指针给t */
	TreeNode * t = term();

	/* 当前单词token为加法运算符单词PLUS或MINUS */
	while ((token.Word == PLUS) || (token.Word == MINUS))

	{
		/* 创建新OpK表达式类型语法树节点，新语法树节点指针赋给p */
		TreeNode * p = newExpNode(Op);

		/* 语法树节点p创建成功,初始化p第一子节点成员child[0]	*
		 * 返回语法树节点指针给p的运算符成员attr.op				*/
		if (p != NULL)
		{
			p->noline = linelinshi;
			p->treechild[0] = t;
			p->Figure.ExceptionFigure.op = token.Word;

			/* 将函数返回值t赋成语法树节点p */
			t = p;

			/* 当前单词token与指定加法运算单词(为PLUS或MINUS)匹配 */
			match(token.Word);

			/* 调用元处理函数term(),函数返回语法树节点指针给t的第二子节点成员child[1] */
			t->treechild[1] = term();
		}
	}
	/* 函数返回表达式类型语法树节点t */
	return t;
}

// 功  能 项处理函数														
// 产生式 < 项 > ::= < 因子 > { < 乘法运算符 > < 因子 > }					
// 说  明 该函数根据产生式调用相应递归处理函数,生成表达式类型语法树节点		
TreeNode * term()

{
	/* 调用因子处理函数factor(),函数返回语法树节点指针给t */
	TreeNode * t = factor();

	/* 当前单词token为乘法运算符单词TIMES或OVER */
	while ((token.Word == TIMES) || (token.Word == OVER))

	{
		/* 创建新的OpK表达式类型语法树节点,新节点指针赋给p */
		TreeNode * p = newExpNode(Op);

		/* 新语法树节点p创建成功,初始化第一个子节点成员child[0]为t	*
		 * 将当前单词token赋值给语法树节点p的运算符成员attr.op		*/
		if (p != NULL)
		{
			p->noline = linelinshi;
			p->treechild[0] = t;
			p->Figure.ExceptionFigure.op = token.Word;
			t = p;
		}

		/* 当前单词token与指定乘法运算符单词(为TIMES或OVER)匹配 */
		match(token.Word);

		/* 调用因子处理函数factor(),函数返回语法树节点指针赋给p第二个子节点成员child[1] */
		p->treechild[1] = factor();

	}
	/* 函数返回表达式类型语法树节点t */
	return t;
}



// 功  能 返回语句部分的处理函数	                    	        
// 产生式 < returnStm > ::=   RETURN                                
// 说  明 函数根据文法产生式,调用相应的递归处理函数,生成语法树节点  
TreeNode * ReturnStm()
{
	TreeNode * t = newSentenceNode(Return);
	match(RETURN);
	if (t != NULL)
		t->noline = linelinshi;
	return t;
}

// 功  能 输入语句部分的处理函数	                    	        
// 产生式 < inputStm > ::=    READ(id)                              
//说  明 函数根据文法产生式,调用相应的递归处理函数,生成语法树节点  
TreeNode * InputStm()
{
	TreeNode * t = newSentenceNode(Read);
	match(READ);
	match(LPAREN);
	if ((t != NULL) && (token.Word == ID))
	{
		t->noline = linelinshi;
		strcpy(t->name[0], token.Mean);
		(t->samenum)++;
	}
	match(ID);
	match(RPAREN);
	return t;
}


//功  能 赋值语句部分的处理函数	                    	        
//产生式 < assignmentRest > ::=  variMore : = exp                  
// 说  明 函数根据文法产生式,调用相应的递归处理函数,生成语法树节点  
TreeNode * AssignmentRest()
{
	TreeNode * t = newSentenceNode(Assign);

	/* 赋值语句节点的第一个儿子节点记录赋值语句的左侧变量名，*
	/* 第二个儿子结点记录赋值语句的右侧表达式*/
	if (t != NULL)
	{
		t->noline = linelinshi;

		/*处理第一个儿子结点，为变量表达式类型节点*/
		TreeNode * child1 = newExpNode(VarType);
		if (child1 != NULL)
		{
			child1->noline = linelinshi;
			strcpy(child1->name[0], tempname);
			(child1->samenum)++;
			VariMore(child1);
			t->treechild[0] = child1;
		}

		/*赋值号匹配*/
		match(ASSIGN);

		/*处理第二个儿子节点*/
		t->treechild[1] = Exception();

	}
	return t;
}


// 功  能 变量处理函数												
// 产生式 variMore   ::=  ε                             			
//                       | [exp]            {[}                     
//                      | . fieldvar       {DOT}                  
// 说  明 该函数根据产生式调用相应的递归处理变量中的几种不同类型	
void VariMore(TreeNode * t)
{
	switch (token.Word)
	{
	case ASSIGN:
	case TIMES:
	case EQ:
	case LT:
	case PLUS:
	case MINUS:
	case OVER:
	case RPAREN:
	case RMIDPAREN:
	case SEMI:
	case COMMA:
	case THEN:
	case ELSE:
	case FI:
	case DO:
	case ENDWH:
	case END:
		break;
	case LMIDPAREN:
		match(LMIDPAREN);

		/*用来以后求出其表达式的值，送入用于数组下标计算*/
		t->treechild[0] = Exception();

		t->Figure.ExceptionFigure.varkind = ArrayMember;

		/*此表达式为数组成员变量类型*/
		t->treechild[0]->Figure.ExceptionFigure.varkind = Identifier;
		match(RMIDPAREN);
		break;
	case DOT:
		match(DOT);
		/*第一个儿子指向域成员变量结点*/
		t->treechild[0] = FieldVar();

		t->Figure.ExceptionFigure.varkind = FieldMember;

		t->treechild[0]->Figure.ExceptionFigure.varkind = Identifier;
		break;
	default:
		ReadNextToken(&token);
		syntaxError("unexpected token is here!");
		break;
	}
}

// 功  能 变量处理函数												
// 产生式 fieldvar   ::=  id  fieldvarMore                          
// 说  明 该函数根据产生式，处理域变量，并生成其语法树节点       	
TreeNode * FieldVar(void)
{
	/*注意，可否将此处的IdEK改为一个新的标识，用来记录记录类型的域*/
	TreeNode * t = newExpNode(VarType);

	if ((t != NULL) && (token.Word == ID))
	{
		t->noline = linelinshi;
		strcpy(t->name[0], token.Mean);
		(t->samenum)++;
	}
	match(ID);

	FieldVarMore(t);

	return t;
}

// 功  能 变量处理函数												
// 产生式 fieldvarMore   ::=  ε                             		
//                           | [exp]            {[}                 
// 说  明 该函数根据产生式调用相应的递归处理域变量为数组类型的情况	
void FieldVarMore(TreeNode * t)
{
	switch (token.Word)
	{
	case ASSIGN:
	case TIMES:
	case EQ:
	case LT:
	case PLUS:
	case MINUS:
	case OVER:
	case RPAREN:
	case SEMI:
	case COMMA:
	case THEN:
	case ELSE:
	case FI:
	case DO:
	case ENDWH:
	case END:
		break;
	case LMIDPAREN:
		match(LMIDPAREN);

		/*用来以后求出其表达式的值，送入用于数组下标计算*/
		t->treechild[0] = Exception();
		t->treechild[0]->Figure.ExceptionFigure.varkind = ArrayMember;
		match(RMIDPAREN);
		break;
	default:
		ReadNextToken(&token);
		syntaxError("unexpected token is here!");
		break;
	}
}

// 功  能 因子处理函数														
// 产生式 factor ::= ( exp ) | INTC | variable                  			
// 说  明 该函数根据产生式调用相应的递归处理函数,生成表达式类型语法树节点	
TreeNode * factor()

{
	/* 函数返回语法树节点指针t初始为为NULL */
	TreeNode * t = NULL;

	switch (token.Word)
	{
	case INTC:

		/* 创建新的ConstK表达式类型语法树节点,赋值给t */
		t = newExpNode(Const);

		/* 新语法树节点t创建成功,当前单词token为数字单词NUM						*
		 * 将当前单词名tokenString转换为整数并赋给语法树节点t的数值成员attr.val	*/
		if ((t != NULL) && (token.Word == INTC))
		{
			t->noline = linelinshi;
			t->Figure.ExceptionFigure.value = atoi(token.Mean);
		}

		/* 当前单词token与数字单词NUM匹配 */
		match(INTC);
		break;

		/* 当前单词token为标识符单词ID */
	case ID:

		/* 创建新的IdK表达式类型语法树节点t */
		t = variable();
		break;

		/* 当前单词token为左括号单词LPAREN */
	case LPAREN:

		/* 当前单词token与左括号单词LPAREN匹配 */
		match(LPAREN);

		/* 调用表达式处理函数exp(),函数返回语法树节点指针给t */
		t = Exception();

		/* 当前单词token与右括号单词RPAREN匹配 */
		match(RPAREN);

		break;

		/* 当前单词token为其它单词 */
	default:
		ReadNextToken(&token);
		syntaxError("unexpected token is here!");
		break;
	}
	/* 函数返回表达式类型语法树节点t */
	return t;
}


// 功  能 变量处理函数												
// 产生式 variable   ::=   id variMore                   			
// 说  明 该函数根据产生式,	处理变量，生成其语法树节点              
TreeNode * variable()
{
	TreeNode * t = newExpNode(VarType);

	if ((t != NULL) && (token.Word == ID))
	{
		t->noline = linelinshi;
		strcpy(t->name[0], token.Mean);
		(t->samenum)++;
	}

	match(ID);
	VariMore(t);
	return t;
}

// 功  能 函数声明中参数声明部分的处理函数	        	        	
// 产生式 < formList > ::=  id  fidMore                             
// 说  明 函数根据文法产生式,调用相应的递归处理函数,生成语法树节点  
void FormList(TreeNode * t)
{
	if (token.Word == ID)
	{
		strcpy(t->name[(t->samenum)], token.Mean);
		t->samenum = (t->samenum) + 1;
		match(ID);
	}
	FidMore(t);
}

// 功  能 函数声明中参数声明部分的处理函数	        	        	
// 产生式 < fidMore > ::=   ε |  , formList                        
// 说  明 函数根据文法产生式,调用相应的递归处理函数,生成语法树节点  
void FidMore(TreeNode * t)
{
	switch (token.Word)
	{
	case SEMI:
	case RPAREN:   break;
	case COMMA:
		match(COMMA);
		FormList(t);
		break;
	default:
		ReadNextToken(&token);
		syntaxError("unexpected token is here!");
		break;
	}
}
// 功  能 语法分析函数												
// 说  明 该函数把词法分析程序作为子程序调用,采用递归下降法			
//		  根据产生式调用递归处理函数,函数为源程序创建语法分析树		
TreeNode * parse()

{
	TreeNode * t = NULL;

	/* 从文件Tokenlist中取得第一个单词,将词法信息送给token */

	ReadNextToken(&token);

	/* 开始调用基本语法分析处理函数,递归下降处理 */
	t = Program();

	/* 当前单词token不是ENDFILE,报代码在文件结束前提前结束错误 */
	if (token.Word != ENDFILE)
		syntaxError("Code ends before file\n");

	/* 函数返回语法树根节点t */
	return t;
}
static int indentno = 0;
/* 功  能 空格打印函数									*/
/* 说  明 该函数打印指定数量空格,用于表示子树缩进		*/
/********************************************************/
static void printSpaces(void)

{
	int i;

	/* 按给定缩进量indentno打印空格进行缩进	*
	 * 其中缩进量indentno总能保持非负			*/
	for (i = 0; i < indentno; i++)
		fprintf(listing, " ");

}


// 功  能 打印空格                                         
// 说  明 在输出文件中打印个数为参数tabnum的空格           
void printTab(int tabnum)
{
	for (int i = 0; i < tabnum; i++)
		fprintf(listing, " ");
}


/*用于存储当前子树缩进格数, 初始为0		*/



/** 增量/减量缩进宏定义 **/
#define INDENT indentno+=4
#define UNINDENT indentno-=4
//功  能 把语法树输出，显示在listing文件中           
// 说  明 该函数运用了宏来定义增量减量的缩进          
void  printTree(TreeNode  *tree)
{
	int i;

	/* 增量缩进宏,每次进入语法树节点都进行增量缩进 */
	INDENT;

	/* 函数参数给定语法树节点指针tree非NULL(空) */
	while (tree != NULL)
	{
		
		/*打印行号*/
		if (tree->noline == 0)
		{
			printTab(9);
		}
		else
			switch ((int)(tree->noline / 10))
			{
			case 0:
				fprintf(listing, "line:%d", tree->noline);
				printTab(3);
				break;
			case 1:
			case 2:
			case 3:
			case 4:
			case 5:
			case 6:
			case 7:
			case 8:
			case 9:
				fprintf(listing, "line:%d", tree->noline);
				printTab(2);
				break;
			default:
				fprintf(listing, "line:%d", tree->noline);
				printTab(1);
			}

		/* 调用函数printSpaces,打印相应的空格,进行缩进 */
		printSpaces();

		switch (tree->nodekind)
		{
		case Pro:
			fprintf(listing, "%s  ", "Pro"); break;
		case ProHead:
		{fprintf(listing, "%s  ", "ProHead");
		fprintf(listing, "%s  ", tree->name[0]);
		}
		break;
		case Dec:
		{  fprintf(listing, "%s  ", "Dec");
		if (tree->Figure.ProcFigure.paramtype == Varpa)
			fprintf(listing, "%s  ", "var param:");
		if (tree->Figure.ProcFigure.paramtype == Val)
			fprintf(listing, "%s  ", "value param:");
		switch (tree->kind.dec)
		{
		case  Array:
		{
			fprintf(listing, "%s  ", "Array");
			fprintf(listing, "%d  ", tree->Figure.ArrayFigure.up);
			fprintf(listing, "%d  ", tree->Figure.ArrayFigure.low);
			if (tree->Figure.ArrayFigure.childtype == Char)
				fprintf(listing, "%s  ", "Char");
			else if (tree->Figure.ArrayFigure.childtype == Integer)
				fprintf(listing, "%s  ", "Integer");
		}; break;
		case  Char:
			fprintf(listing, "%s  ", "Char"); break;
		case  Integer:
			fprintf(listing, "%s  ", "Integer"); break;
		case  Record:
			fprintf(listing, "%s  ", "Record"); break;
		case  Id:
			fprintf(listing, "%s  ", "Id");
			fprintf(listing, "%s  ", tree->Figure.typeName);
			break;
		default:
			fprintf(listing, "error1!");
			Error = TRUE;
		};
		if (tree->samenum != 0)
			for (int i = 0; i <= (tree->samenum); i++)
			{
				fprintf(listing, "%s  ", tree->name[i]);

			}
		else
		{
			fprintf(listing, "wrong!no var!\n");
			Error = TRUE;
		}
		} break;
		case Type:
			fprintf(listing, "%s  ", "Type"); break;

		case Var:
			fprintf(listing, "%s  ", "Var");
			//if (tree->table[0] != NULL)
			//	fprintf(listing, "%d  %d  ", tree->table[0]->attrIR.More.VarAttr.off, tree->table[0]->attrIR.More.VarAttr.level);
			break;

		case FuncDec:
			fprintf(listing, "%s  ", "FuncDec");
			fprintf(listing, "%s  ", tree->name[0]);
			//if (tree->table[0] != NULL)
			//	fprintf(listing, "%d %d %d  ", tree->table[0]->attrIR.More.ProcAttr.mOff, tree->table[0]->attrIR.More.ProcAttr.nOff, tree->table[0]->attrIR.More.ProcAttr.level);
			break;

		case StmL:
			fprintf(listing, "%s  ", "StmL"); break;

		case Stmt:
		{ fprintf(listing, "%s  ", "Stmt");
		switch (tree->kind.stmt)
		{
		case If:
			fprintf(listing, "%s  ", "If"); break;
		case While:
			fprintf(listing, "%s  ", "While"); break;

		case Assign:
			fprintf(listing, "%s  ", "Assign");
			break;

		case Read:
			fprintf(listing, "%s  ", "Read");
			fprintf(listing, "%s  ", tree->name[0]);
			//if (tree->table[0] != NULL)
				//fprintf(listing, "%d   %d  ", tree->table[0]->attrIR.More.VarAttr.off, tree->table[0]->attrIR.More.VarAttr.level);
			break;

		case Write:
			fprintf(listing, "%s  ", "Write"); break;

		case Call:
			fprintf(listing, "%s  ", "Call");
			fprintf(listing, "%s  ", tree->name[0]);
			break;

		case Return:
			fprintf(listing, "%s  ", "Return"); break;

		default:
			fprintf(listing, "error2!");
			Error = TRUE;
		}
		}; break;
		case Exp:
		{ fprintf(listing, "%s  ", "Exp");
		switch (tree->kind.exp)
		{
		case Op:
		{ fprintf(listing, "%s  ", "Op");
		switch (tree->Figure.ExceptionFigure.op)
		{
		case EQ:   fprintf(listing, "%s  ", "="); break;
		case LT:   fprintf(listing, "%s  ", "<"); break;
		case PLUS: fprintf(listing, "%s  ", "+"); break;
		case MINUS:fprintf(listing, "%s  ", "-"); break;
		case TIMES:fprintf(listing, "%s  ", "*"); break;
		case OVER: fprintf(listing, "%s  ", "/"); break;
		default:
			fprintf(listing, "error3!");
			Error = TRUE;
		}

		if (tree->Figure.ExceptionFigure.varkind == ArrayMember)
		{
			fprintf(listing, "ArrayMember  ");
			fprintf(listing, "%s  ", tree->name[0]);
		}
		}; break;
		case Const:
			fprintf(listing, "%s  ", "Const");
			switch (tree->Figure.ExceptionFigure.varkind)
			{
			case Identifier:
				fprintf(listing, "Id  ");
				fprintf(listing, "%s  ", tree->name[0]);
				break;
			case FieldMember:
				fprintf(listing, "FieldMember  ");
				fprintf(listing, "%s  ", tree->name[0]);
				break;
			case ArrayMember:
				fprintf(listing, "ArrayMember  ");
				fprintf(listing, "%s  ", tree->name[0]);
				break;
			default:
				fprintf(listing, "var type error!");
				Error = TRUE;
			}

			fprintf(listing, "%d  ", tree->Figure.ExceptionFigure.value);
			break;
		case VarType:
			fprintf(listing, "%s  ", "VarType");
			switch (tree->Figure.ExceptionFigure.varkind)
			{
			case Identifier:
				fprintf(listing, "Identifier  ");
				fprintf(listing, "%s  ", tree->name[0]);
				break;
			case FieldMember:
				fprintf(listing, "FieldMember  ");
				fprintf(listing, "%s  ", tree->name[0]);
				break;
			case ArrayMember:
				fprintf(listing, "ArrayMember  ");
				fprintf(listing, "%s  ", tree->name[0]);
				break;
			default:
				fprintf(listing, "var type error!");
				Error = TRUE;
			}
			//if (tree->table[0] != NULL)
			//	fprintf(listing, "%d   %d  ", tree->table[0]->attrIR.More.VarAttr.off, tree->table[0]->attrIR.More.VarAttr.level);

			break;
		default:
			fprintf(listing, "error4!");
			Error = TRUE;
		}
		}; break;
		default:
			fprintf(listing, "error5!");
			Error = TRUE;
		}

		fprintf(listing, "\n");

		/* 对语法树结点tree的各子结点递归调用printTree过程 *
		 * 缩进写入列表文件listing						   */
		for (i = 0; i < 3; i++)
			printTree(tree->treechild[i]);

		/* 对语法树结点tree的兄弟节点递归调用printTree过程 *
		 * 缩进写入列表文件listing						   */
		tree = tree->brother;
	}

	/* 减量缩进宏,每次退出语法树节点时减量缩进 */
	UNINDENT;
}
void Free_Tree(TreeNode*root)
{
	if (root == NULL)
		return;
	for (int i = 0; i < 3; i++)
	{
		if (root->treechild[i] != NULL)
			Free_Tree(root->treechild[i]);
		root->treechild[i] = NULL;
	}
	if (root->brother != NULL)
	{
		Free_Tree(root->brother);
		root->brother = NULL;
	}
	if (root != NULL)
	{
		free(root);
		root = NULL;
	}
}

/* 语法分析追踪标志,初始为FALSE.如果为TRUE,		*
 * 将语法分析信息输出到中间文件listing			*/
int TraceParse = TRUE;


/*******************************************************/
//            语义分析
/*******************************************************/

//创建当前空符号表
/*
  遇到新的无声明的标识符时创建新的空符号表，并返回它的指针
*/
SymbTable*NewTable()
{
	SymbTable*table = (SymbTable*)malloc(sizeof(SymbTable));
	table->next = NULL;
	table->idfinger.kind = typeKind;
	table->idfinger.idtype = NULL;
	table->next = NULL;
	table->idfinger.Random.VarFigure.isParam = false;
	return table;
}

//创建一个符号表
/*
 当进入一个新的局部化单位时，调用本子程序。功能是建立一个空符号表
 符号加一，偏移初始化为0
*/
void CreatTable()
{
	Level++;//层数加一
	scope[Level] = NULL;//申请了新的一层scope栈的空间
	Off = 7;//偏移初始化由于目标代码生成阶段，首先要保存：动态链指针，返回地址，过程层数，三个累加寄存器，sp 到display 表的偏移量等 7 个信息，故这里 initOff 定为常数 7。
}
//撤销一个符号表
void DestroyTable()
{
	Level--;
}
//登记标识符和属性到符号表
/*
将标识符名，标识符属性登记在符号表中，登记成功，返回值为
真，Entry 指向登记的标识符在符号表中的位置；登记不成功，返回
值为假，Entry 值为空。
输入为一个标识符id和一个属性figure和符号表指针entry，将给定
的id和属性登记到符号表中，并返回登记项的地址。
在登记时应检查在本层中是否有重复声明错误，为此声明Enter返回类型
为bool，如果已有id项则该变量返回真，否则返回假
*/
bool Enter(char *id, IDfigure *figure, SymbTable**entry)
{
	bool Present = false;
	int result = 1;
	SymbTable*current = scope[Level];
	SymbTable*press = scope[Level];
	if (scope[Level] == NULL)
	{
		current = NewTable();
		scope[Level] = current;
	}
	else
	{
		while (current != NULL)
		{
			press = current;
			result = strcmp(id, current->idName);
			if (result == 0)
			{
				fprintf(listing, "重复定义错误!");
				Error = TRUE;
				Present = true;
			}
			else
				current = press->next;
		}
		if (Present == false)
		{
			current = NewTable();
			press->next = current;
		}

	}
	//将标识符名和属性登记到表中
	strcpy(current->idName, id);
	current->idfinger.idtype = figure->idtype;
	current->idfinger.kind = figure->kind;
	switch (figure->kind)
	{
	case typeKind:break;//类型标识符
	case varKind:
		current->idfinger.Random.VarFigure.level = figure->Random.VarFigure.level;
		current->idfinger.Random.VarFigure.off = figure->Random.VarFigure.off;
		current->idfinger.Random.VarFigure.access = figure->Random.VarFigure.access;
		break;
	case procKind:
		current->idfinger.Random.ProcFigure.level = figure->Random.ProcFigure.level;
		current->idfinger.Random.ProcFigure.param = figure->Random.ProcFigure.param;
		break;
	default: break;
	}
	(*entry) = current;
	return Present;

}

//寻找表项地址（符号表中查找标识符）
/*
   对给定的标识符id (id为字符串类型) 求出其表项地址,
   并在entry的实参单元中返回表项地址。如果符号表里没
   有所找的id项,则返回present为0,则函数中的参数entry
   赋值为指向该表项地址的指针;否则,present赋值为1。
*/
int FindEntry(char *id, SymbTable**entry)
{
	int present = 0;//返回值
	int result = 1;//标识符名字比较结果
	int level = Level;//临时记录层数
	SymbTable*findentry = scope[level];
	while ((level != -1) && (present != 1))
	{
		while ((findentry != NULL) && (present != 1))
		{
			result = strcmp(id, findentry->idName);
			if (result == 0)
				present = 1;//标识符名字相同
			else
				findentry = findentry->next;//若没找到则继续链表中国查找
		}
		if (present != 1)
		{
			level--;
			findentry = scope[level];//上一个局部化区继续找
		}
	}
	if (present != 1)
	{
		(*entry) = NULL;
	}
	else
	{
		(*entry) = findentry;
	}
	return present;
}

/* 功  能  查找纪录的域名								*/
/* 说  明  返回值为是否找到标志，变量Entry返回此域名在  */
/*		   纪录的域表中的位置.							*/

bool FindField(char*id, fieldChain*head, fieldChain**Entry)
{
	bool present = false;
	fieldChain*currentf = head;//记录当前节点
	while ((currentf != NULL) && (present == false))//从表头开始查找这个标识符，直到找到或到达表位
	{
		if (strcmp(currentf->id, id) == 0)
		{
			present = true;
			if (Entry != NULL)
				(*Entry) = currentf;
		}
		else
			currentf = currentf->next;
	}
	return present;
}
//属性查询
//对给行表项地址，求出其属性值，并将其返回给fingure的实参单元中
IDfigure Findfinger(SymbTable*entry)
{
	IDfigure finger = entry->idfinger;
	return finger;
}



//判断类型是否相容
/*
 由于TINY语言中只有整数类型，字符类型，数组类型和记录类型，故
 类型相容等于类型等价，只需判断每个结构类型的内部表示产生的至真至是否相同即可
*/
int Compare(TypeIR*tp1, TypeIR*tp2)
{
	int present;
	if (tp1 != tp2)
		present = 0;//类型不等
	else
		present = 1;//类型等价
	return present;
}



//创建当前空类型内部表示
TypeIR*NewTy(TypeKind kind)
{
	TypeIR*table = (TypeIR*)malloc(sizeof(TypeIR));
	switch (kind)
	{
	case intTy:
	case charTy:
	case boolTy:
		table->kind = kind;
		table->size = 1;
		break;
	case arrayTy:
		table->kind = arrayTy;
		table->More.ArrayFigure.indexTy = NULL;
		table->More.ArrayFigure.elemTy = NULL;
		break;
	case recordTy:
		table->kind = recordTy;
		table->More.body = NULL;
		break;
	}
	return table;
}





//创建当前空形参链表
//函数返回新申请的单元地址
ParamTable*NewParam()
{
	ParamTable *p = (ParamTable*)malloc(sizeof(ParamTable));
	p->entry = NULL;
	p->next = NULL;
	return p;
}




//函数初始化整数类型，字符类型，布尔类型的内部表示
void initialize()
{
	intPtr = NewTy(intTy);
	charPtr = NewTy(charTy);
	boolPtr = NewTy(boolTy);
	//scope栈的各层指针设为空
	for (int i = 0; i < 1000; i++)
		scope[i] = NULL;
}
//错误提示
//在输出文件中显示错误提示，并给全局量Error赋值为1
void ErrorPrompt(int line, char*name, const char*message)
{
	fprintf(listing, "Line:%d： %s ", line, name);
	fprintf(listing, "%s", message);
	Error = 1;
	exit(0);
}

/* 在符号表中寻找已定义的类型名字         */
/* 调用寻找表项地址函数FindEntry，返回找到的表项地址
指针entry。如果present为FALSE，则发生无声明错误。
如果符号表中的该标识符的属性信息不是类型，则非类
型标识符。该函数返回指针指向符号表中的该标识符的
类型内部表示。								    */
TypeIR*nameType(TreeNode*t)
{
	TypeIR*Ptr = NULL;
	SymbTable*entry = NULL;
	int present;
	//类型表示符也需要往上层查找
	present = FindEntry(t->Figure.typeName, &entry);
	if (present == 1)
	{
		//检查该标识符是否为类型标识符
		if (entry->idfinger.kind != typeKind)
			ErrorPrompt(t->noline, t->Figure.typeName, "不是类型标识符\n");
		else
			Ptr = entry->idfinger.idtype;
	}
	else//未找到该标识符
	{
		ErrorPrompt(t->noline, t->Figure.typeName, "没有声明！！！\n");
	}
	return Ptr;
}
//处理数组类型内部表示
//类型为数组类型时需要检查下标是否合法
TypeIR*arrayType(TreeNode*t)
{
	TypeIR *Ptr0 = NULL;
	TypeIR*Ptr1 = NULL;
	TypeIR*Ptr = NULL;
	//检查数组上下界的合法性
	char*NAME = new char[2];
	NAME[0] = ' ';
	NAME[1] = '\0';
	if ((t->Figure.ArrayFigure.low) > (t->Figure.ArrayFigure.up))
	{
		ErrorPrompt(t->noline, NAME, "数组上下界不合法！\n");
		Error = 1;
	}
	else
	{
		Ptr0 = TypeProcess(t, Integer);//调用类型分析函数处理下标类型
		Ptr1 = TypeProcess(t, t->Figure.ArrayFigure.childtype);//调用类型分析函数处理元素类型
		Ptr = NewTy(arrayTy);//指向一新创建的类型信息表
		Ptr->size = ((t->Figure.ArrayFigure.up) - (t->Figure.ArrayFigure.low) + 1)*Ptr1->size;//记录本类型长度
		Ptr->More.ArrayFigure.indexTy = Ptr0;
		Ptr->More.ArrayFigure.elemTy = Ptr1;
		Ptr->More.ArrayFigure.low = t->Figure.ArrayFigure.low;
		Ptr->More.ArrayFigure.up = t->Figure.ArrayFigure.up;

	}
	return Ptr;
}

//处理表达式分析，重点检查运算分量的类型相容性，求表达式的类型，其中
//参数kind用来表示实参是变参还是值参
TypeIR*Expr(TreeNode*t, AccessKind*kind)
{
	bool present = false;
	SymbTable*entry = NULL;
	TypeIR*Eptr0 = NULL;
	TypeIR*Eptr1 = NULL;
	TypeIR*Eptr = NULL;
	if (t != NULL)
	{
		switch (t->kind.exp)
		{
		case Const:
			Eptr = TypeProcess(t, Integer);
			Eptr->kind = intTy;
			if (kind != NULL)
				(*kind) = dir;//直接变量
			break;
		case VarType:
			//var=id的情形
			if (t->treechild[0] == NULL)
			{	//在符号表中查找此标识符
				present = FindEntry(t->name[0], &entry);
				t->table[0] = entry;
				if (present != 0)
				{
					//id不是变量
					if (Findfinger(entry).kind != varKind)
					{
						ErrorPrompt(t->noline, t->name[0], "不是变量错误！！！\n");
						Eptr = NULL;
					}
					else
					{
						Eptr = entry->idfinger.idtype;
						if (kind != NULL)
							(*kind) = indir;//间接变量
					}

				}
				else//标识符未声明
				{
					ErrorPrompt(t->noline, t->name[0], "没有声明！！！\n");

				}
			}
			else//Var=Var0[E]的情形
			{
				if (t->Figure.ExceptionFigure.varkind == ArrayMember)
					Eptr = arrayVar(t);
				else//var=var0.id的情形
				{
					if (t->Figure.ExceptionFigure.varkind == FieldMember)
						Eptr = recordVar(t);
				}
			}
			break;
		case Op:
			//递归调用儿子节点
			Eptr0 = Expr(t->treechild[0], NULL);
			if (Eptr0 == NULL)
				return NULL;
			Eptr1 = Expr(t->treechild[1], NULL);
			if (Eptr1 == NULL)
				return NULL;
			//类型判别
			present = Compare(Eptr0, Eptr1);
			if (present != 0)
			{
				switch (t->Figure.ExceptionFigure.op)
				{
				case LT:
				case EQ:
					Eptr = boolPtr;
					break;//条件表达式
				case PLUS:
				case MINUS:
				case TIMES:
				case OVER:
					Eptr = intPtr;
					break;//算数表达式

				}
				if (kind != NULL)
				{
					(*kind) = dir;//直接变量
				}
			}
			else
			{
				char NAME[2];
				NAME[0] = ' ';
				NAME[1] = '\0';
				ErrorPrompt(t->noline, NAME, "运算符不匹配");
			}
			break;

		}
	}
	return Eptr;
}



//处理数组变量的下标分析
//检查var:=var0[E]中var0是不是数组类型，E是不是和数组的下标变量类型匹配
TypeIR*arrayVar(TreeNode*t)
{
	bool present = false;
	SymbTable *entry = NULL;
	TypeIR*Eptr0 = NULL;
	TypeIR*Eptr1 = NULL;
	TypeIR*Eptr = NULL;
	//符号表中查找该标识符
	present = FindEntry(t->name[0], &entry);
	t->table[0] = entry;
	//找到
	if (present != false)
	{
		//var0不是变量
		if (Findfinger(entry).kind != varKind)
		{
			ErrorPrompt(t->noline, t->name[0], "不是变量！！！\n");
			Eptr = NULL;
		}
		else//var0不是数组类型变量
		{
			if (Findfinger(entry).idtype != NULL)
			{
				if (Findfinger(entry).idtype->kind != arrayTy)
				{
					ErrorPrompt(t->noline, t->name[0], "不是数组变量！！！\n");
					Eptr = NULL;
				}
				else
				{
					//检查E的类型是否与下标类型相符
					Eptr0 = entry->idfinger.idtype->More.ArrayFigure.indexTy;
					if (Eptr0 == NULL)
						return NULL;
					Eptr1 = Expr(t->treechild[0], NULL);//intptr;
					if (Eptr1 == NULL)
						return NULL;
					present = Compare(Eptr0, Eptr1);
					char NAME[2];
					NAME[0] = ' ';
					NAME[1] = '\0';
					if (present != 1)
					{
						ErrorPrompt(t->noline, NAME, "类型不匹配！！！\n");
						Eptr = NULL;

					}
					else
					{
						Eptr = entry->idfinger.idtype->More.ArrayFigure.elemTy;
					}

				}

			}

		}


	}
	else//标识符未声明
	{
		ErrorPrompt(t->noline, t->name[0], "没有声明！！！\n");

	}
	return Eptr;
}

//处理记录变量中域的分析
//检查var:=var0.id中的var0是不是记录类型变量，id是不是该记录类型中的域成员
TypeIR*recordVar(TreeNode*t)
{
	int present = 0;
	int result = 1;
	SymbTable*entry = NULL;
	TypeIR*Eptr0 = NULL;
	TypeIR*Eptr1 = NULL;
	TypeIR*Eptr = NULL;
	fieldchain*currentP = NULL;
	//在符号表中查找此标识符
	present = FindEntry(t->name[0], &entry);
	t->table[0] = entry;
	//找到
	if (present != 0)
	{
		//Var0不是变量
		if (Findfinger(entry).kind != varKind)
		{
			ErrorPrompt(t->noline, t->name[0], "不是变量！！！\n");
			Eptr = NULL;
		}
		else//var0不是记录类型变量
		{
			if (Findfinger(entry).idtype->kind != recordTy)
			{
				ErrorPrompt(t->noline, t->name[0], "不是记录类型变量!\n");
				Eptr = NULL;
			}
			else//检查id是否是合法域名
			{
				Eptr0 = entry->idfinger.idtype;
				currentP = Eptr0->More.body;
				while ((currentP != NULL) && (result != 0))
				{
					result = strcmp(t->treechild[0]->name[0], currentP->id);
					//如果相等
					if (result == 0)
						Eptr = currentP->UnitType;
					else
						currentP = currentP->next;
				}
				if (currentP == NULL)
				{
					if (result != 0)
					{
						ErrorPrompt(t->treechild[0]->noline, t->treechild[0]->name[0], "不是域类型！！！\n");
						Eptr = NULL;
					}
				}
				else//id是数组变量
				{
					if (t->treechild[0]->treechild[0] != NULL)
					{
						Eptr = arrayVar(t->treechild[0]);
					}
				}
			}
		}
	}
	else//标识符未声明
	{
		ErrorPrompt(t->noline, t->name[0], "没有声明！！！\n");

	}
	return Eptr;
}





//处理语句状态
//根据语法树节点中的kind项判断应该转向处理哪个语句类函数
void statement(TreeNode*t)
{
	char NAME[2];
	NAME[0] = ' ';
	NAME[1] = '\0';
	switch (t->kind.stmt)
	{
	case If:ifstatement(t); break;
	case While:whilestatement(t); break;
	case Assign:assignstatement(t); break;
	case Read:readstatement(t); break;
	case Write:writestatement(t); break;
	case Call:callstatement(t); break;
	case Return:returnstatement(t); break;
	default:
		ErrorPrompt(t->noline, NAME, "语句类型错误！！！\n");
		break;
	}
}














//创建当前空记录类型中域的链表
//函数返回该类型的新的链表的单元地址
fieldChain*NewBody()
{
	fieldChain*P = (fieldChain*)malloc(sizeof(fieldChain));
	P->next = NULL;
	P->off = 0;
	P->UnitType = NULL;
	return P;
}



/*
各种语句处理函数
*/
//条件语句分析语法树三个儿子节点
void ifstatement(TreeNode*t)
{
	AccessKind*kind = NULL;
	TypeIR*exp = Expr(t->treechild[0], kind);
	char NAME[2];
	NAME[0] = ' ';
	NAME[1] = '\0';
	if (exp != NULL)
	{
		//处理条件表达式
		if (exp->kind != boolTy)
			ErrorPrompt(t->noline, NAME, "条件表达式错误！！！\n");
		else
		{
			TreeNode*p = t->treechild[1];
			//处理then语句序列部分
			while (p != NULL)
			{
				statement(p);
				p = p->brother;
			}
			t = t->treechild[2];//必有三儿子
			//处理else语句部分
			while (t != NULL)
			{
				statement(t);
				t = t->brother;
			}
		}
	}
}

//处理循环语句
//分析语法树的两个儿子节点
void whilestatement(TreeNode*t)
{
	TypeIR*p = Expr(t->treechild[0], NULL);
	char NAME[2];
	NAME[0] = ' ';
	NAME[1] = '\0';
	if (p != NULL)
	{
		//处理条件表达式部分
		if (p->kind != boolTy)
			ErrorPrompt(t->noline, NAME, "条件表达式错误！！！\n");
		else
		{
			t = t->treechild[1];
			//处理循环部分
			while (t != NULL)
			{
				statement(t);
				t = t->brother;
			}
		}
	}
}

//处理输入语句
//分析语法树节点检查变量有无声明和是否为变量错误
void readstatement(TreeNode*t)
{
	SymbTable*entry = NULL;
	int present = 0;
	//用id检查整个符号表
	present = FindEntry(t->name[0], &entry);
	t->table[0] = entry;
	//未查到表示变量未声明
	if (present == 0)
		ErrorPrompt(t->noline, t->name[0], "未声明！！！\n");
	else
	{
		//不是变量标识符
		if (entry->idfinger.kind != varKind)
			ErrorPrompt(t->noline, t->name[0], "不是变量标识符！\n");

	}
}

//处理输出语句分析
//分析输出语句中的表达式是否合法
void writestatement(TreeNode*t)
{
	TypeIR*p = Expr(t->treechild[0], NULL);
	char NAEM[2];
	NAEM[0] = ' ';
	NAEM[1] = '\0';
	if (p != NULL)
	{
		//如果表达式类型为bool类型，报错
		if (p->kind == boolTy)
			ErrorPrompt(t->noline, NAEM, "表达式不合法");
	}
}


//处理函数返回语句分析
//分析函数返回语句是否在主程序中出现
void returnstatement(TreeNode *t)
{
	char a[2];
	a[0] = ' ';
	if (Level == 0)
	{
		//如果返回语句出现在主程序中，报错
		ErrorPrompt(t->noline, a, "返回语句错误!!!\n");
	}
}


//赋值语句分析
//赋值语句的语义分析的终点是检查复制好两端分量的类型相容性
void assignstatement(TreeNode*t)
{
	SymbTable*entry = NULL;
	int present = 0;
	TypeIR*p = NULL;
	TypeIR*pp = NULL;
	TreeNode*child1 = NULL;
	TreeNode*child2 = NULL;
	child1 = t->treechild[0];
	child2 = t->treechild[1];
	if (child1->treechild[0] == NULL)
	{
		//在符号表中查找该标识符
		present = FindEntry(child1->name[0], &entry);
		if (present != 0)
		{
			//id不是变量
			if (Findfinger(entry).kind != varKind)
			{
				ErrorPrompt(child1->noline, child1->name[0], "不是变量！！！\n");
				pp = NULL;
			}
			else
			{
				pp = entry->idfinger.idtype;
				child1->table[0] = entry;
			}
		}
		else//标识符未声明
		{
			ErrorPrompt(child1->noline, child1->name[0], "没有声明！！！！！\n");

		}

	}
	else/*Var0[E]*/
	{
		if (child1->Figure.ExceptionFigure.varkind == ArrayMember)
			pp = arrayVar(child1);
		else//Var0.id
		{
			if (child1->Figure.ExceptionFigure.varkind == FieldMember)
				pp = recordVar(child1);
		}
	}
	if (pp != NULL)
	{
		if ((t->nodekind == Stmt) && (t->kind.stmt == Assign))
		{
			//检查是不是赋值号两侧类型等价
			char a[2];
			a[0] = ' ';
			a[1] = '\0';
			p = Expr(child2, NULL);
			if (!Compare(p, pp))
			{
				ErrorPrompt(t->noline, a, "两侧表达式不是同一类型！！！\n");
			}
		}
		//赋值语句中不能出现函数调用
	}
}


//函数调用语句分析
/*
  函数调用语句的语义分析首先检查符号表求出其属性中的Param部分，
  并用它检查形参和实参之间的对应关系是否正确
*/
void callstatement(TreeNode*t)
{
	char a[2];
	a[0] = ' ';
	a[1] = '\0';
	AccessKind kind;
	int present = 0;
	SymbTable *entry = NULL;
	TreeNode*p = NULL;
	//用id检查整个符号表
	present = FindEntry(t->treechild[0]->name[0], &entry);
	t->treechild[0]->table[0] = entry;
	//未查到表示函数未声明
	if (present == 0)
	{
		ErrorPrompt(t->noline, t->treechild[0]->name[0], "函数未声明！！！\n");

	}
	else
	{
		//id不是函数名
		if (Findfinger(entry).kind != procKind)
		{
			ErrorPrompt(t->noline, t->name[0], "不是函数名！！！\n");

		}
		else//形式参数和实在参数匹配
		{
			p = t->treechild[1];
			//paramP指向形参符号表的表头
			ParamTable*paramP = Findfinger(entry).Random.ProcFigure.param;
			while ((p != NULL) && (paramP != NULL))
			{
				
				SymbTable*paraentry = paramP->entry;
				TypeIR*etp = Expr(p, &kind);//实参
				if ((Findfinger(paraentry).Random.VarFigure.access == indir) && kind == dir)
					ErrorPrompt(p->noline, a, "参数种类不匹配！！！\n");
				else
				{
					//参数类型不匹配
					if ((Findfinger(paraentry).idtype) != etp)
						ErrorPrompt(p->noline, a, "参数类型不匹配\n");
					
				}
				p = p->brother;
				paramP = paramP->next;
			}
				//参数个数不匹配
			if ((p != NULL) || (paramP != NULL))
			{
				ErrorPrompt(t->treechild[1]->noline, a, "参数个数不匹配！！！\n");

			}


			
		}

	}
}






//处理执行体部分的语义分析
void Body(TreeNode*t)
{
	if (t->nodekind == StmL)
	{
		TreeNode*p = t->treechild[0];
		while (p != NULL)
		{
			statement(p);//调用语句状态处理函数
			p = p->brother;//依次读入语法树语句序列的兄弟节点
		}
	}
}

/*处理记录类型的内部表示
类型为记录类型时，是由记录体组成的。其内部节点需
要包括3个信息 : 一是空间大小size；二是类型种类标志
recordTy; 三是体部分的节点地址body。记录类型中的
域名都是标识符的定义性出现，因此需要记录其属性。
*/
TypeIR*recordType(TreeNode*t)
{
	TypeIR*Ptr = NewTy(recordTy);//新建记录类型节点
	t = t->treechild[0];//从语法树的儿子节点读取域信息
	fieldChain*Ptr2 = NULL;
	fieldChain*Ptr1 = NULL;
	fieldChain*body = NULL;
	while (t != NULL)
	{
		//填写ptr2指向的内容节点
		//诸如int a，b；
		for (int i = 0; i < t->samenum; i++)
		{
			Ptr2 = NewBody();
			if (body == NULL)
				body = Ptr1 = Ptr2;
			//填写Ptr2的各个成员内容
			strcpy(Ptr2->id, t->name[i]);
			Ptr2->UnitType = TypeProcess(t, t->kind.dec);
			Ptr2->next = NULL;
			//如果Ptr1！=Ptr2那么将指针后移
			if (Ptr2 != Ptr1)
			{
				//计算新申请的单元off
				Ptr2->off = (Ptr1->off) + (Ptr1->UnitType->size);
				Ptr1->next = Ptr2;
				Ptr1 = Ptr2;
			}
		}
		//处理完同类型变量后取语法树的兄弟节点
		t = t->brother;

	}
	//处理记录类型内部结构
	//取Ptr2的off为最后整个记录的size
	Ptr->size = Ptr2->off + (Ptr2->UnitType->size);
	//将域链链入记录类型的body部分
	Ptr->More.body = body;
	return Ptr;
}


/*
   该函数处理函数头中的参数声明的语义分析
   在新的符号表中登记所有形参的表项，构造形参表项的
   地址表，并有param指向其。
*/
ParamTable*ParaDecList(TreeNode*t)
{
	TreeNode*p = NULL;
	ParamTable*Ptr1 = NULL;
	ParamTable*Ptr2 = NULL;
	ParamTable*head = NULL;
	if (t != NULL)
	{
		if (t->treechild[0] != NULL)
			p = t->treechild[0];//程序声明节点的第一个儿子节点
		CreatTable();//进入新的局部化区
		Off = 7;//子程序中的变量初始偏移设为8
		VarDecPart(p);//变量声明部分
		SymbTable*Ptr0 = scope[Level];
		while (Ptr0 != NULL)//只要不为空就访问其兄弟节点
		{
			//构造形参符号表，并使其连接至符号表的param项
			Ptr2 = NewParam();
			if (head == NULL)
				head = Ptr1 = Ptr2;
			Ptr2->entry = Ptr0;
			Ptr2->next = NULL;

			if (Ptr2 != Ptr1)
			{
				Ptr1->next = Ptr2;
				Ptr1 = Ptr2;
			}
			Ptr0 = Ptr0->next;
		}

	}
	return head;//返回形参符号表的头指针
}







/*
   该函数处理函数头的语义分析
   在当前层符号表中填写函数标识符的属性；在新层符号
   表中填写形参标识符的属性。其中过程的大小和代码都
   需以后回填。
*/
SymbTable*HeadProcess(TreeNode*t)
{
	IDfigure  idfigure;
	bool present = false;
	SymbTable *entry = NULL;
	//属性
	idfigure.kind = procKind;
	idfigure.idtype = NULL;
	idfigure.Random.ProcFigure.level = Level + 1;
	if (t != NULL)
	{
		//登记函数的符号表项
		present = Enter(t->name[0], &idfigure, &entry);
		t->table[0] = entry;
		//处理形参声明表
	}
	entry->idfinger.Random.ProcFigure.param = ParaDecList(t);
	return entry;
}








//类型分析
//处理语法树的当前节点类型，构造出当前节点类型的内部
//表示并将其地址返回给Ptr类型内部表示的地址
TypeIR*TypeProcess(TreeNode*t, DeclareKind deckind)
{
	TypeIR*Ptr = NULL;
	switch (deckind)
	{
	case Id:Ptr = nameType(t); break;//类型为自定义表示符
	case Array:Ptr = arrayType(t); break;//类型为数组类型
	case Record:Ptr = recordType(t); break;//类型为记录类型
	case Integer:Ptr = intPtr; break;//类型为整数类型
	case Char:Ptr = charPtr; break;//类型为字符类型
	}
	return Ptr;

}



/********************************************/
//              类型声明的语义分析
/*********************************************/
/*该函数处理类型声明的语义分析                     */
/*遇到类型T时，构造其内部节点TPtr；对于"idname=T"构
造符号表项；检查本层类型声明中是否有重复定义错误.*/
void TypeDecPart(TreeNode*t)
{
	bool present = false;
	IDfigure idfigure;
	SymbTable*entry = NULL;
	//属性作为参数
	idfigure.kind = typeKind;
	//遍历语法树的兄弟节点
	while (t != NULL)
	{
		//调用记录属性函数，返回是否重复声明错误和入口地址
		present = Enter(t->name[0], &idfigure, &entry);
		if (present != false)
		{
			ErrorPrompt(t->noline, t->name[0], "重复定义了！！！\n");
			entry = NULL;
		}
		else
			entry->idfinger.idtype = TypeProcess(t, t->kind.dec);
		t = t->brother;
	}

}


//处理变量声明的语义分析
/*
   当遇到变量标识符id时把id登记到符号表中，检查重复性定义；遇到类型时
   构造其内部表示
*/
void varDecList(TreeNode*t)
{
	IDfigure idfigure;
	bool p = false;
	SymbTable*entry = NULL;
	while (t != NULL)
	{
		idfigure.kind = varKind;
		for (int i = 0; i < t->samenum; i++)
		{
			idfigure.idtype = TypeProcess(t, t->kind.dec);
			//判断是值参还是变参access（dir，indir）
			if (t->Figure.ProcFigure.paramtype == Varpa)
			{
				idfigure.Random.VarFigure.access = indir;
				idfigure.Random.VarFigure.level = Level;
				//计算 形参的偏移
				idfigure.Random.VarFigure.off = Off;
				Off++;
			}//如果是变参则偏移加一
			else
			{
				idfigure.Random.VarFigure.access = dir;
				idfigure.Random.VarFigure.level = Level;
				//值参偏移
				if (idfigure.idtype != NULL)
				{
					idfigure.Random.VarFigure.off = Off;
					Off = Off + (idfigure.idtype->size);
				}

			}//否则为值参偏移加变量类型的size
			//登记该变量的属性及名字，并返回其类型内部指针
			p = Enter(t->name[i], &idfigure, &entry);
			if (p != false)
			{
				ErrorPrompt(t->noline, t->name[i], "重定义！！！\n");
			}
			else
				t->table[i] = entry;

		}
		if (t != NULL)
		{
			t = t->brother;
		}
	}
	//如果是主程序，则记录此时偏移
	if (Level == 0)
		mainoff = Off;
	else//如果不是主程序则记录此时偏移，用于下面填写过程信息表的noff信息
		savedOff = Off;

}

//处理变量声明的语义分析
//调用变量处理分析函数
void VarDecPart(TreeNode*t)
{
	varDecList(t);
}



//函数处理过程声明的语义分析
//在当前层符号表中填写过程标识符的属性，在新层符号表中
//填写形参标识符的属性
void procDecPart(TreeNode*t)
{
	TreeNode*p = t;
	SymbTable*entry = HeadProcess(t);//处理过程头
	t = t->treechild[1];
	char*NAME = new char[2];
	NAME[0] = ' ';
	NAME[1] = '\0';
	//如果过程内部存在声明部分，则处理声明部分
	while (t != NULL)
	{
		switch (t->nodekind)
		{
		case Type:TypeDecPart(t->treechild[0]); break;
		case Var:VarDecPart(t->treechild[0]); break;
			//如果声明部分有函数声明，则跳出循环，先填写noff和moff
			//等信息，再处理函数声明的循环处理，负责无法保存noff和moff的值
		case FuncDec:break;
		default:
			ErrorPrompt(t->noline, NAME, "在语法分析树种没有这个节点类型！！\n");
			break;
		}
		if (t->nodekind == FuncDec)
			break;
		else
			t = t->brother;
	}
	entry->idfinger.Random.ProcFigure.noff = savedOff;
	entry->idfinger.Random.ProcFigure.moff = entry->idfinger.Random.ProcFigure.noff + entry->idfinger.Random.ProcFigure.level + 1;
	//过程活动记录的长度等于noff加上display表的长度
	//diaplay表的长度等于过程所在层数加一
	//处理程序的声明部分
	while (t != NULL)
	{
		procDecPart(t);
		t = t->brother;
	}
	t = p;
	Body(t->treechild[2]);//处理Block
	//函数部分结束删除进入形参时新建立的符号表
	if (Level != -1)
		DestroyTable();//结束当前scope
}







//函数处理总的语义分析
//对语法树进行分析
void analyze(TreeNode*t)
{
	char a[2];
	a[0] = ' ';
	a[1] = '\0';
	SymbTable*entry = NULL;
	TreeNode *p = NULL;
	TreeNode*pp = t;
	//创建符号表
	CreatTable();
	//调用类型内部表示初始化函数
	initialize();
	//语法树声明节点
	p = t->treechild[1];
	while (p != NULL)
	{
		switch (p->nodekind)
		{
		case Type:TypeDecPart(p->treechild[0]); break;
		case Var:VarDecPart(p->treechild[0]); break;
		case FuncDec:procDecPart(p); break;
		default:
			ErrorPrompt(p->noline, a, "没有这个节点类型！！\n");
			break;
		}
		p = p->brother;
	}
	//程序体
	t = t->treechild[2];
	if (t->nodekind == StmL)
		Body(t);
	//撤销符号表
	if (Level != -1)
		DestroyTable();
	//输出语义错误
	if (Error == 1)
		fprintf(listing, "\n语义错误如下：\n");
	//如果无错误则输出提示信息
	else
	{
		fprintf(listing, "\n无语义错误！！！！\n");
	}
}


//打印符号表的一层
void PrintOneLayer(int level)
{
	SymbTable*t = scope[level];
	fprintf(listing, "\n第%d层符号表    \n\n\n",level);
	while (t != NULL)
	{
		//输出表示符的名字
		fprintf(listing, "%s:     ", t->idName);
		IDfigure*idfigure = &(t->idfinger);
		//输出表示符的类型信息，过程表示符除外
		if (idfigure->idtype != NULL)
		{
			switch (idfigure->idtype->kind)
			{
			case intTy:fprintf(listing, "intTy  "); break;
			case charTy:fprintf(listing, "charTy  "); break;
			case arrayTy:fprintf(listing, "arrayTy  "); break;
			case recordTy:fprintf(listing, "recordTy  "); break;
			default:fprintf(listing, "error type!!!!"); break;
			}

		}//输出表示符的类别并根据不同类型输出不同其他属性
		switch (idfigure->kind)
		{
		case typeKind:
			fprintf(listing, "typeKind  "); break;
		case varKind:
			fprintf(listing, "varKind  ");
			fprintf(listing, "Level=%d  ", idfigure->Random.VarFigure.level);
			fprintf(listing, "Offset=%d ", idfigure->Random.VarFigure.off);
			switch (idfigure->Random.VarFigure.access)
			{
			case dir:fprintf(listing, "dir "); break;
			case indir:fprintf(listing, "indir  "); break;
			default:fprintf(listing, "errorkind "); break;
			}
			break;
		case procKind:
			fprintf(listing, "funckind  ");
			fprintf(listing, "Level=%d  ", idfigure->Random.ProcFigure.level);
			fprintf(listing, "Noff=%d  ", idfigure->Random.ProcFigure.noff);
			break;

		default:fprintf(listing, "error !!!");
			break;
		}
		fprintf(listing, "\n");
		t = t->next;
	}
}


//打印符号表

void PrintSymbTable()
{
	//层数从零开始
	int level = 0;
	while (scope[level] != NULL)
	{
		PrintOneLayer(level);
		level++;
	}
}


/********************************************************/
/*                主函数                                 */
/*********************************************************/
int main()
{
	char*file = (char*)malloc(sizeof(char) * 100);//输入要编译的文件名
	printf("请输入源程序文件名:\n");
	scanf("%s", file);
	source = fopen(file, "r");//用只读方式打开file并将文件指针传送给source。
	if (source == NULL)
	{
		printf("File %s is not found\n", file);
		exit(1);
	}
	listing = stdout;
	fprintf(listing, "\n程序结构（含行号）%s\n", file);
	//词法分析程序
	getToken();
	int a;
	printf("\n\n\n请选择功能：\n1、词法分析token序列\n2、语法分析递归下降\n3、语法分析LL1\n4、语义分析错误输出以及符号表打印\n0:退出\n");
	printf("请输入要选择的功能键：\n");
	scanf("%d", &a);
	while (true)
	{
		if (a == 1)
		{
			printf("Token序列:\n\n");
			printTokenlist();
			//释放链表

		}
		else if (a == 2)
		{
			TreeNode * syntaxTree;
			fprintf(listing, "\n语法分析:\n");
			syntaxTree = parse();
			fprintf(listing, "\n语法树:\n\n");
			printTree(syntaxTree);
			Free_Tree(syntaxTree);//释放整棵树
			fpnum = 0;
		}
		else if (a == 3)
		{
			/*****************************/
			//语法分析LL1
			/*****************************/
			fprintf(listing, "敬请期待！！！\n");
		}
		else if (a == 4)
		{
			TreeNode*syntaxTree;
			syntaxTree = parse();
			fprintf(listing, "\n语义分析：\n");
			fprintf(listing, "\n检查语义错误……\n");
			analyze(syntaxTree);
			if (!Error)
				fprintf(listing, "\n无错误！！！\n");
			fpnum = 0;
			fprintf(listing, "是否打印所生成的符号表？？？？\n1:是/0:不是  \n");
			int b;
			scanf("%d", &b);
			if ( b ==1)
			{
				PrintSymbTable();
				getchar();
			}
			else
				getchar();
		}
		else if (a == 0)
		{
			fprintf(listing, "\n程序已退出!!!!");
			exit(1);
		}
		printf("\n\n\n请选择功能：\n1、词法分析token序列\n2、语法分析递归下降\n3、语法分析LL1\n4、语义分析错误输出以及符号表打印\n0:退出\n");
		printf("请输入要选择的功能键：\n");
		scanf("%d", &a);

	}

}
//D:\1.txt
