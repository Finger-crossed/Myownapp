



编译原理课程设计
实验报告



指导教师：刘磊
年    级： 2018级
班    级：26班
小组编号： 1
组长学号姓名：陈建康
组员学号姓名：陈杰
组员学号姓名：王禹谦


2021年 4  月 14  日
计算机科学与技术学院


完成实验内容
1、SNL的词法分析程序，输入SNL源程序，将单词的内部表示序列输出到stdout中和文件中。
2、SNL的递归下降分析程序，通过从第一个任务生成的token序列中读取Token序列，进而通过语法错误检查看是否有语法错误，如果有输出语法错误的错误提示信息，如果没有语法错误则打印语法树（层次文本的输出）
3、SNL的LL（1）分析程序，通过从生成的保存Token序列的链表中读取生成的token序列进行LL1分析方法的语法错误检查信息和语法树的打印
4、SNL的语义分析程序，通过利用第二个程序（第三个程序也可）所生成的语法树进行语义错误信息的输出如果没有语义错误则提示无语义错误，通过在分析语义的时候建立符号表来协助语义分析的错误检查，在扫描声明部分语法树时建立符号表在扫描语句部分语法树时查表检查语义
5、SNL语义分析完成后打印相应的符号表信息，通过逐层打印的方式输出到stdout中以验证所生成的语义分析过程中符号表的正确性。

小组成员任务完成情况
姓名	具体完成任务	工作量
百分比
陈建康	
1、词法分析2、语法分析中递归下降3、语义分析4、符号表打印5、输出界面的设计6、报告的撰写（自己的程序部分）	
陈杰	     	
王禹谦		
小组成员协作情况







实验平台与编程语言
实验平台：Microsoft Visual Studio2017
编程语言：C语言
实验方案设计
一、词法分析
源程序一般为字符串形式，词法分析是在单词一级上进行的，所以我们首先应该先将源程序翻译成单词序列也就是Token表，词法分析按顺序进行扫描源程序，根据源程序的此法规则输出与其等价的Token序列。
首先想要分析单词序列就必须对单词序列进行分类，一般可以分为保留字如 main，break等；标识符如变量名，常量名等；常数如整型常数，浮点型常数等；运算符如+，-，*，/等；界限符如‘，’，‘；’，‘（）’等；保留字和表示符都是字母开头够跟若干个字母或数字构成，因此保留字是表示符的子类，故当遇到这样的情况先查保留字表，之后查表示符表，对于保留字表程序中利用WordType进行枚举。
而单词的Token形式在程序中利用一个结构体TokenType进行设置，其中包括单词所在源程序中的行号lineshow，单词的词法信息WordType（类型枚举）和单词的语义信息用输出Mean来进行表示。
DFA：
单词的正则表达式形式可以用有限自动机来进行实现，而对于识别单词的有限自动机来讲，根据不同单词的构成规则进行构造相应的状态转换图，而对于如果能识别所有单词的有限自动机来讲，首先将初始状态合并为一个唯一的初态然后花间调整状态冲突和对冲突转台重新编号。
在程序中是利用先利用一个链表进行相应存储每个单词的Token序列，这个链表是一个结构体ChainNodeType，其中属性包括单词的Token形式Token和指向链表下一个单词的指针nextToken，在利用函数getToken取得逐个单词函数来进行相应的链表节点的赋值，在这里面就用到DFA来识别单词进行链表节点Token的输入，首先定义自动机的各个状态以进行识别单词，分为开始状态（刚开始识别），完成状态（识别结束），数字状态（第一个字符为数字），标识符状态（第一个字符为字模），赋值状态（=），数组下标界限状态（.），字符标志状态（‘），注释状态（{}）。
其识别过程如下：只要不是文件结束标志即当前的单词不是ENDFILE，就一直进行确定单词Token类型加入到链表中，对于每一个单词设置一个数组tokenword用来存储当前正在识别的单词，在识别过程中设置存储标志save，如果为1则说明当前字符要存入当前的tokenword中，反之则不能存入（不需要存入的单词），对于遇到识别的每一个单词自动机状态初始为start，之后根据遇到不同字符转换不同状态来进行，当遇到不需存储的字符则直接令save为0即可，对于空格，回车等也无需存储。在其中要灵活进行回退处理，例如当扫描到‘：’时自动机状态改为赋值状态则只有下一个字符为‘=’时才可令当前字符的WordType为赋值，否则回退一个字符，令当前所读的单词类别为设置为ERROR进行处理。
当state为标识符状态时识别标识符后还要调用checkbaoliu函数检查是否是保留还是自定义的标识符，按情况输出，标识符输出ID，而保留字则输出相应的KeyWords，在整数状态识别并组合数字，输出单词number，对于扫描到的=或：=如果扫描到=时向前回退一个单词进行识别如果是：则输出：=否则输出=；在注释状态略过注释内容知道扫描到}，或是EOF并不生成单词；当扫描到数组下标界限，如果下一个字符不是‘.’则为程序结束标志，否则为数组下表界限标志，在字符标志中如果读入的下一个是字母或数字则继续读下一个字符，如果下一个字符是“ ’ ”，则为字符标志其他均出错。在错误状态表示词法分析程序从源程序读入了一个不合法的字符打印错误信息ERROR，略过错误单词转开始状态继续识别和组合下一个单词符号。 
     在识别过程中用到了取下一个字符和向前回退一个字符函数，这两个函数在程序中分别用getnext（）和disgetnext（）来进行操作。
     在输出界面中为了保存单词的行号等信息，在取字符的同时也将源程序及其行号打印在了stdout中，实现机制如下：
     通过没读一个字符，调用getnext（）函数，首先定义全局变量lineno来记录当前处理的字符的行号，通过每次从源文件中读取255个字符存于line数组中进行操作，一行的最大字符数这里约定源程序每行字符数不能超过255个，在没结束前没取出255个单词就将line里的信息连同行号一并打印在stdout中，然后用哪个linelarge记录读入的行中世纪的字符个数然后每读一个返回line【Line++】即可，当Line小于linelarge时说明该行还未处理完处理该行字符，否则lineno++循环处理。
     而disgetnext则是通过Line--实现单词回退。
     在存取单词的时候如果自动机状态处于完成状态，则判断其是否为表示符，是的话在判断是否为保留字，通过checkbaoliu（char*a）来实现，在立即定义的保留字中查询是否匹配若是返回保留字的单词否则返回ID表示自定义标识符，其中保留字存储在自己定义的baoliu【】结构体数组中，属性有单词和类别。之后将每个取出的单词的行号，词法和语义存入链表节点中去，知道当前所读单词为文件结束符。
     这样整个程序的单词Token就存入了链表（链表头为chainHead）中了。
     为了以后的语法分析能够直接从链表中读取单词的Token序列则利用了自定义函数ChainToFile（ChainNode*chainhead）将链表中的信息存入到了文件Tokenlist中方便一以后语法分析用。
     而ChainToFile（）函数实现如下：
     传入Token链表首指针，然后创建新文件tokenlist将链表中的内容进行fwrite写入文件中。
     为了使得在stdout中显示Token结构，利用printTokenlist（）函数进行词法分析Token序列的输出打印：通过在上一步文件中的Token序列进行扫描，打印行号，遇到保留字单词输出Key Words再打印语义信息，其他如等号小于等直接输出符号了，对于数字则输出Number，val=，字符是Inchar，char=，自定义单词是Identifier，错误就输出Error，未知单词就打印Unkonwn token，在搜索单词是每次搜寻tokenlength长度的单词，这样才可以取得每一个单词。
二、语法分析（递归下降法）
语法分析的输入是从词法分析器输出的源程序的Token形式，在这里是存放在了ChainNode链表当中，也可在词法分析中生成的文件Tokenlist中按一个token大小的字节进行读取获得。之后根据语法的文法规则进行分析处理，如果分析有错误则输出错误信息，如果无错误则输出语法的语法树形式。
这里采用从开始符出发进行推导，递归下降分析程序，针对递归下降方法，我们是通过文法的predict集合进行推导，看源程序的文法是否是正确的文法。
在主程序分析语法时要每次读取单词的Token序列，而在程序中使用ReadNextToken来实现读取文件中的Token序列，利用fseek函数越过整数倍token大小的字节后读取相应的Token单词。
输出的话是输出与源程序结构相同的语法树，为了呈现的比较清晰，又加入了类型声明，变量声明，函数声明，语句序列等标志节点。
而语法树的数据结构如下：
语法树的节点类型程序中使用TreeTypeKind来表示，其中分为两类，其一是标志节点，有树根的Pro，程序头ProHead，子结点都是类型声明节点Type，子结点都是变量声明节点Var，函数声明节点FuncDec，语句序列节点StmL，这些只表示节点的类型没有其他的具体内容，而另一个为具体节点，有语句声明节点Stmt，表达式节点Exp，声明节点Dec。其中声明节点DeclareKind可分为数组Array，字符Char，整数Integer等，语句类型节点SentenceKind枚举有If，While,Assign等，表达式类型节点ExceptionKind枚举有Op操作符，常数Const以及标识符变量类型VarType。在语法树中记录节点其他属性，其中分为数组，过程以及表达式，而在过程总要记录过程的参数类型ParamType枚举为值参Val和变参Varpa，在表达式属性中有变量的类别VarKind枚举为标识符Identifier，数组成员ArrayMember和域成员类型FieldMember以及表达式的结果类型ExpKind枚举为空Void，整形INTEger，布尔类型Boolean。
而语法树节点的数据结构如下：treechild【0..2】指向子语法树，brother指向兄弟语法树指针，noline记录源代码的行号，nodekind为节点类型，域类型kind记录语法树节点的具体类型，samenum记录相同类型的变量个数，name标识符的名称，table为指针数组成员为各个标志符在符号表中的入口，属性结构体Figuer中由数组属性包括数组上下界和数组子类型，只有当kind中的声明类型为Array时有效，过程属性中的过程参数类型，，表达式属性包括表达式操作符，表达式的值以及变量的类别和检查类型。在进行语法分析时语法分析程序将根据SNL的文法产生式，为相应的非终极符创建一个语法树节点并为之赋值。
递归下降法：即对每个非终极符按其产生式结构构造相应语法分析子程序，其中终极符产生匹配命令，即在程序中调用match函数，而对于非终极符则产生过程调用命令，其中match函数检查当前输入符是否是产生式所要求的单词，如果是则指向下一个单词，如果不是则出错，输出错误信息提示。其中match函数将终极符单词作为函数参数，当前在文件中索取单词与函数参数比较如果一致则取下一个单词，否则打印未匹配的错误信息，继续读下一个单词。
在语法分析中在main函数中利用语法分析函数parse函数来进行递归调用，parse函数读入单词调用总程序处理分析函数返回语法树的根节点，当递归回溯完成后如果当前的token不是文件结束符则说明文件提前结束输出错误信息，否则返回树根t为后面的打印语法树提供语法树的树根TreeNode*t；
而总程序处理分析函数Program内主要生成三个儿子节点treechild[0..2],依次是程序头分析程序ProgramHead（），程序声明部分分析函数DeclarePart（），以及函数体部分处理函数ProcBody（），然后匹配程序结束标志“.”，若成功返回树根结点，否则返回空。
（1）程序头ProgramHead主要是新建程序头结点，匹配program，然后记录程序名于程序头结点，匹配ID，如果成功返回节点否则返回空。声明部分处理函数因为声明语句的文法有类型声明节点，变量声明节点和函数声明节点，并且彼此之间都是作为brother节点的关系，所以先处理类型声明，新建类型节点，调用类型声明处理分析函数TypeDec（），变量声明处理分析函数VarDec()，函数声明部分处理分析函数ProDec（），其中TypeDec生成的接待为类型声明的第一个子结点，VarDec（）为变量声明的第一个子结点。如果没有类型声明节点则令声明部分指针指向变量声明节点依次类推，如果都没有函数返回NULL；函数体分析函数则作为树根的第三个儿子节点，其调用程序体部分分析函数ProgramBody，根据其相应的文法生成相应的递归函数，新建语句标志类型节点，匹配begin，然后调用语句序列函数StmList（）作为语句标志类型节点的第一个儿子节点。
最后匹配END。
     关于新建节点函数虽然写了很多函数但是内部都是大同小异，只拿其中一个来讲，如创建函数类型语法树节点函数newProcNode（），其作用是为语法树创建一个新的函数类型节点，并将语法树成员初始化：首先申请树节点，对于树节点的三个儿子节点初始化为空，兄弟节点也为空，节点类型为函数类型FuncDec，源代码行号为linelinshi，这个是没匹配一个Token时将此Token的行号赋值为linelinshi，相同变量个数为0，标识符名称为空，符号表地址为空。其他新建类型标志节点，新建变量声明标志节点等都一样，只是将里面的nodekind设置为相应的标志节点类型即可。注意在新建语句节点，表达式节点时除了赋值nodekind为相应的类型，还要将具体类型赋值。
      （2）之后则从语法树从左往右进行分析，对于声明标志节点中的类型声明处理函数TypeDec根据读入的下一个单词选择调用typeDeclaration（）函数，如果读到的是Type则调用，否则不做动作根据文法而定。
而对于typeDeclaration其根据文法产生式匹配Type调用TypeDecList（）函数，根据TypeDecList函数的文法产生式，创建新的声明类型节点。调用TypeId()，匹配保留字EQ（=），调用TypeName（），匹配SEMI（；），之后调用TypeDecMore（），返回值给声明类型节点作为其兄弟节点。
其中TypeId（TreeNode*t）是根据读入的单词判断其是否在标识符中，将该字符的语义拷贝到参数t的标识符名字中，之后匹配单词ID。
TypeName（TreeNode*t）根据文法产生式和predict集进行选择调用。当匹配到整型和字符型调用基础类型函数BaseType，当单词为数组或记录类型则调用结构体类型函数StructureType进行赋值，BaseType根据文法产生式进行匹配赋值。
而StructureType则是选择数组类型还是记录类型，前者对读入单词匹配，记录数组上下界数值再匹配保留字最后调用基本函数BaseType记录数组子类型。记录类型RecType则匹配调用与函数FieldDecList（），最后对读入单词匹配FieldDecList根据文法和predict集进行调用函数，判断记录里的单词的类型进行相应的调用，在域中成员互为兄弟节点。
对于TypeDecMore则根据读入的单词或和文法产生式以及predice集进行调用相应的函数。并将该返回的节点作为TypeDecList的兄弟节点。最后FiledDecMore函数是读入单词判断若为END则不做处理否则若为基本类型或数组则递归处理FiledDecList，否则读入下一个token。域中在调用完基本类型等后有IdList函数其是匹配标识符记录标识符名称的，之后递归到用IdMore处理相应函数。
之后是变量声明标志节点VarDec（），根据产生式和读入单词的Predict集调用相应的函数，其实与上面的类型声明类似，如果相应的predict集对应的文法不为空则调用相应的处理函数，如果为Var时调动VarDeclaration（），匹配Var，调用VarDecList（）：创建爱你新的声明节点，根据文法产生式调用typeName，varIdList，VarDecMore，之后根基读到的不同的单词调用varIdList（），之后匹配“；”，之后创建节点VarDecMore（）将其作为新声明节点的兄弟节点。
其中varIdList（）匹配标识符名记录标识符名称如果当前单词为ID，则将当前的标识符名赋值到参数t的成员t.name中匹配id，调用VarIdMore（），根据文法产生式及predict集确定执行哪个分支（是否还有其他变量），队规调用varIdList（）。
最后是过程声明标志节点ProDec（），根据产生式对当前单词进行predict集的判断若为begin则不做动作，若为procedure则调用ProcDeclaration（t），否则读入下一个单词。
对于ProcDeclaration（），创建新的过程节点，匹配Program，匹配标识符名字，之后匹配左括号，调用参数处理函数ParamList（t），匹配右括号，匹配“；”，之后反复调用类型和过程体节点作为其第二个和第三个儿子节点，实现函数的嵌套。
其中参数声明的处理函数ParamList（）根据文法产生式和predict集当匹配为右括号则直接返回，否则调用ParamDecList()并且将该函数返回的节点作为参数处理节点的儿子节点。
对于ParamDecList（）根据文法产生式调用Param和Parammore函数返回节点作为Param的兄弟节点：对于Parmmore（）根据文法产生式根据当前读入的单词如果为右括号则结束否则当前单词是否为“；”，若是则匹配调用ParamDecList（）函数递归调用以看是否有其他的参数声明。
对于param函数则根据产生式选择调用分值函数，令当前节点的参数成员赋值为参数类型，调用TypeName（t）和FormList（t），否则如果当前单词为Var则匹配单词var，t参数成员赋值为参数类型调用调用TypeName（t）和FormList（t）；对于FormList（t），匹配id，执行FidMore（t）函数，FidMore根据产生式要么不做动作要么递归调用FormList（）；
   （3）之后是过程提部分处理函数ProcBody（），调用ProgramBody（）主程序部分处理函数，建立新的句子标志节点，匹配begin，之后令语句部分处理函数StmList（）作为新的句子标志结点的儿子节点，最后匹配end。
     对于语句部分处理函数StmList（），根据产生式调用stm和stmmore处理函数并将后者作为前者的兄弟节点，对于stm根据不同的predict集选择不同的分支，如若当前单词为IF，则调用条件语句处理函数ConditonalStm（），赋值或调用语句特殊，如果当前单词为ID，则应先匹配ID，在调用函数AssCall。
赋值语句和函数调用语句的开始部分都是标识符，所以该函数根据读入的单词选择调用相应的处理程序：当前单词为ASSIGN则调用AssignmentRest（）函数，当前单词为LPAREN则调用CallStmRest（）函数。
针对AssignmentRest（）来讲根据文法生成式创建新的赋值语句类型语法树节点，赋值语句节点的第一个儿子节点记录赋值语句的左侧变量名，第二个儿子节点记录赋值语句的右侧表达式，令第一个儿子节点为变量表达式节点，行号赋值为当前所读Token的行号，将当前所读单词的名字赋值为节点的标识符名字，然后调用变量处理函数VariMore（t），判断下一个单词如果是左中括号则匹配左中括号，表达式结点的第一个儿子节点调用表达式函数Exception（），并将根节点的表达式属性的变量书信该设置为Identifier，匹配有中括号结束，如果当前单词为DOT，则匹配DOT处理域变量函数fieldvar（），让第一个儿子指向域成员节点，令根的表达式属性的变量类型设置为域成员类型，域成员变量节点的表达式属性的变量类型设置为Identifier；否则读下一个TOKEN。
对于域变量处理函数FiledVar（），根据产生式先建立新的变量表达式节点，然后匹配id，赋值标识符的名字，递归调用FieldVarMore（t），该函数根据产生式调用相应的递归处理域变量为数组类型的情况，如果匹配到左括号，则t的第一个儿子节点等于Exception（），然后属性的表达式类型属性为数组类型之后匹配右中括号。否则读取下一个单词。对于表达式处理函数Exception（），调用简单表达式处理函数simple_exp()，返回语法树节点t，当前单词为小于或等于，则创建一个新的运算表达式类型语法树节点p，将简单表达式处理函数的返回值t赋给新语法树节点p的第一个儿子节点作为运算表达式的做运算简式，将当前单词赋给新语法树节点p成员op，作为运算表达式的运算符，并将新的语法树节点p赋给t作为当前语法树节点。匹配小于或等于，调用simple_exp()将返回的值赋给当前语法树二儿子，作为运算表达式的右运算简式。
而simple_exp()根据产生式调用相应递归处理函数，调用原处理函数term（）返回t，如果当前单词token为加法运算符或减法则创建新的操作符表达式类型语法树节点p初始化第一个子结点p的op为当前所读单词，将函数返回值t赋成语法树节点p，当前单词token与指定加法运算单词匹配，调用原处理函数term（）返回语法树节点指针给t的第二子节点。
其中用到的项处理函数term（），调用因子处理函数factor（），返回给t，如果当前单词是乘或除，创建新的操作符表达式类型语法树节点，赋值为p，与上面加减处理一样，之后将匹配乘法运算符单词，第二个孩子节点也为factor（）；
则factor（）因子处理函数，读当前单词，如果为常整型，则创建新的常量表达式语法树节点赋值为t，当前单词为数字，则将当前单词名装换为整数并赋给语法树节点t的数值成员，匹配常整型。如果当前单词token为表示符单词ID，则创建新的标识符表达式类型语法树节点t=variable（），如果当前单词为左括号，则匹配左括号，调用表达式处理函数Exception（），犯规语法树节点指针给t，匹配右表达式。否则读取下一个单词。
其中的变量处理函数variable（）：根据产生式处理变量，建立新的变量表达式节点返回给t，然后将当前单词的语义赋值为t的标识符名字，之后匹配id，递归调用VariMore函数（）；这是所有关于赋值和调用的函数处理。
之后是循环语句部分的处理函数LoopStm（）：根据文法产生式，新建while语句类型节点，匹配WHILE关键字，令节点第一个儿子节点指向表达式Exception（），匹配DO，之后第二个儿子节点指向语句处理函数StmList（），匹配ENDWH关键字，结束返回while语句节点。
条件语句部分处理函数ConditionalStm（），新建IF语句类型节点，匹配IF，小儿子指向Exception（），匹配THEN，之后二儿子指向then之后的语句序列StmList（），如果下一个单词为else则匹配else之后令第三个儿子节点指向else后的语句序列StmList（），否则直接匹配FI返回IF语句节点t；
函数调用语句部分的处理函数CallStmRest（），建立Call类型语法树节点给t，子结点指向实参，匹配保留字LPAREN，函数名的节点用变量表达式的节点，将当前所读的函数名给t的第一个儿子节点的name，调用实参处理函数ActParamList（），将实参处理函数的返回值给t的第二个儿子节点，匹配RPAREN。
      赋予实参处理函数根据文法生成以及相应的predict集，判断当前的单词，如果为右括号则break，如果为ID或为常整数则调用表达式处理函数，如果有的话则调用更多实参处理函数ActParamMore（），返回给t的brother成员，否则读取下一个单词。
      对于更多的实参处理函数ActParamMore（），则读取当前的单词，如果为右括号则直接返回空，否则如果为“，”则递归调用实参处理函数ActParamList（）。
       输入语句部分处理函数InputStm（），建立新的Read语句语法树节点，匹配read和左括号，将下一个单词的语义等赋值给当前节点的name成员，作为read语句的标识符名，匹配ID，匹配右括号。
        输出语句部分处理函数OutputStm（），建立WRITE语句语法树节点，匹配write，左括号，调用表达式处理函数返回值复位新语法树节点成员的第一个儿子节点作为write语句的表达式，匹配右括号，结束。
        返回语句部分处理函数ReturnStm（），建立新的RETURN语句语法树节点，匹配return，返回。
        在调用parse函数后语法树已经形成了，其中的根节点为root，则打印语法分析数函数printTree（TreeNode*tree），为了使得语法树看上去美观明了，这里是先打印根节点，之后对三个儿子节点递归打印，儿子都打印完成后再打印兄弟节点，每次进入一个节点的时候回缩进固定数目的空格，跳出后悔回退缩进的空格数目，会使得同一层的兄弟在同一列上，在没输出一行之前先在行首打印行号，之后根据行的数字进行相应的补充空格填写，如果是两位数，则输出行号后向后打印2个空格，如果是三位数打印一个，如果是移位数打印三个空格，这样在后面统一打印空格时才会使得同兄弟在同一列上。之后对数的nodekind进行判断，如果是Pro则为程序开始，ProHead则为程序头，打印程序头并且打印节点的name即为程序名，如果是Dec则为声明类型节点，对节点的过程参数进行判断打印，形实参数的信息打印，之后判断节点的具体类型，如果是数组Array则打印上下界，对数组的子类型进行判断输出，如果是字符整型记录标识符等则直接打印，如果是标识符的话则要把表示符名打印出来。对相同类型的变量进行依次打印，如果samenum为0的话说明没有变量声明错误！！如果节点类型为Type则打印Type，如果为Var则打印Var，如果是函数声明则打印FuncDec，打印函数的名字，如果是语句序列标志节点，则打印StmL，如果是语句类型则打印Stmt，对语句类型的具体类型进行判断，如果是If，While，Assign等直接打印，如果是Read的话则打印Read，将标识符名字打印出来。如果是表达式类型，则打印Exp，对具体类型，如果是操作符，则打印Op，对表达式属性的操作符进行判断，打印相应的符号。如果是数组成员，则打印ArrayMember，接着打印树组成员的语义信息。如果是常量，则打印Const，对表达式的变量类型进行判断，输出相应的类型和语义信息。如果是百纳领，则输出VarType，之后和Const一样处理。
语法分析（递归下降法）结束！！
三、语法分析（LL1分析法）



四、语义分析
其主要是对语法分析后得到的内部结构进行语义处理，这里我做了两个任务，一是进行必要的语义检查输出错误的语义信息，二是建立符号表和信息表保存标识符的语义信息，类型信息和过程信息（数组信息和记录信息），形参信息等。
在语义分析阶段建造符号表当遇到标识符声明部分时每当遇到一个名字声明就以此名字查符号表若表中无此项，则将该名字填入表中，若已有则重复声明报告语义错误。在符号表中其属性类型特征等信息在此阶段完成。
在本程序中通过建立统一的符号表来存放不同种类的标识符，这里建立表示符的属性结构定义，成员有指向标识符的类型内部表示的指针，标识符的类型（typeKind，varKind，procKind），这是有表示共有的属性，之后根据不同的种类标识符属性有所不同，进而利用一个联合体来进行组织，分为标量标识符属性结构体包括参数类型，层数，偏移，是参数还是普通变量的布尔类型标志；过程名标识符结构体包括过程层数，参数表（包括指向形参所在符号表中的地址入口，和指向下一个形参的指针），过程活动记录大小，sp到display的偏移量，过程入口地址。
因为类型分为整数类型，字符、数组、记录、布尔类型，其中前两个是标准类型内部表示可以事先构造，数组和记录类型等构造则要在变量声明或类型声明时构造。进而可以构造类型内部结构体，成员有共有的类型所占大小，和表示符的类型（枚举为整数，字符，数组和记录），前二类只有大小和种类表示，后两种的话还需有数组的话是指向数组下标类型的内部标志和指向数组元素类型的内部表示即指向整数或字符，记录类型的话则要指向记录的与类型表地址，因此要设置域类型表单元结构体成员有变量名，所在记录中的偏移，域中成员的类型和指向域中下一个变量指针。
而符号表的结构定义成员有标识符的名字，标识符的结构属性和指向符号表中下一个元素的指针。
因为SNL语言是分程序结构语言，每个可独立编译的程序单元可能是多模块或单模块，故处理标识符时在分程序首部某声明中遇到一个标识符时查相应本层分程序符号表，若已有则重复声明语义错误否则登记。当在分程序的语句中遇到一个标识符时首先在该层分程序的符号表中查找若找不到则在其直接外层符号表中查找，直到找到，如果查遍了所有没有则未声明语义错误。
故在本程序中分层建立符号表，使各分程序的符号表项连续地排列在一起。建立分程序表用来记录各层分程序符号表的起始位置：分程序表用SymbTable类型数组Scope表示，Scope【i】指向第i层符号表。
在进行语义分析之前先处理符号表的相关函数：
建立当前空符号表NewTable（），用来解决当遇到新的无声明的标识符时创建新的空符号表并返回指针：令符号表的类型设为typeKind，其他置空。
建立某层新符号表CreateTable（），全局变量Level加一，scope栈当成为空，偏移初始化为7（考虑目标代码生成阶段需要保存的东西）。
撤销一个符号表DestroyTable（）即令当前层减一即退回一个局部化区。
向符号表登记信息Enter（），为布尔类型输入标识符id属性和符号表指针，首先在本层起始位置先比较当前标识符名称和要存入的id是否同名如果是则输出重复定义错误语义错误，否则知道找到最后位置新建一个符号表项，将标识符名属性存入符号表中。如果总函数返回真则存入否则存入失败。
符号表中查找标识符函数FindEntry（），给定id求出表项地址返回地址指针，从当前层开始查找，找到地址指针返回当前找到的表项地址，否则返回空。总函数返回真表示找到否则未找到。
查找记录的域名FindField（），输入为id，域链头和返回指针，从表头查找标识符，返回真假表示找到与否。
打印符号表PrintSymbTable（），从层数0开始逐层打印，而打印一层的函数PrintOneLayer（level）：符号表指针指向相应的层的头结点，然后输出名字，输出相应的标识符的类型信息（过程标识符除外），然后按照不同的类别输出相应的其他属性。
之后进行语义分析：主要完成建立符号表和进行语义错误检查，将变量，类型和过程标识符添加到符号表，先根遍历语法树，先进行标识符属性填表，对语法树节点处理过程中只对类型声明节点，变量声明节点和过程声明节点处理，查符号表判断是否重复或填入符号表相关的信息。还有无声明错误和类型一致性检查等。在类型一致性检查过程中按照后跟次序遍历语法树在遍历处理语法分析树的子结点之后再处理该节点进行类型检查，只针对运算类型表达式节点，常量表达式，标识符表达式，条件，赋值，写，循环和过程调用语句类型节点进行检查。
语义分析的输入是语法树由上一部分语法分析产生，输出错误语义信息和根据使用者的意愿打印符号表（在无予以错误的前提下）。
在语法分析生成语法树后根节点为root，则传入语义分析总程序analyze（root）：创建符号表，调用类型内部表示初始化函数initialize（），该函数主要是初始化整数类型字符类型和布尔类型的内部表示和初始化scope数组，对于三个类型的创建，为了便于简化，从开始就创建了三个内部类型指针始终指向相应类型的内部表示（intPtr，charPtr，booPtr）。
通过创建内部类型函数NewTy（TypeKind*）来实现：创建新的内部类型指针，如果为前三种类型的令表示符类型为相应类型，大小设为1.如果是 数组则类型设置为arrayTy，下标和元素类型设置为空，记录类型设为recordTy，记录的域链也设置为空，返回内部类型指针给相应的内部类型时针。
   之后只对语法树声明节点处理（变量声明，类型声明以及过程声明），因为声明节点为根节点的第二个儿子节点，所以令p指向声明标志节点。检查p的节点类型，如果是类型节点，则调用类型语义分析函数TypeDecPart（）从第一个儿子节点进行处理，如果是变量声明节点，则调用变量语义分析函数VarDecPart（）与类型处理一样，如果是过程声明节点，则调用过程语义分析函数procDecPart（），否则输出错误信息，遍历完再遍历兄弟节点。直到所有兄弟节点全部处理完，之后处理程序体，令根指向三儿子节点程序体节点，如果有则调用执行体语义分析处理函数Body（），然后输出相关的语义说明提示。有错误输出错误提示，无则输出正确提示。
其中类型声明语义分析处理函数TypeDecPart（p），对于类型t其已经有类型内部节点的生成，对于idname=T构造符号表项检查时候有重复定义错误：对于该节点的标识符名字，然后调用Enter函数查符号表中是否已经存在该标识符名字，如果存在则重复定义语义错误，否则返回入口地址，调用构造当前节点类型的内部表示处理函数TypeProcess（），进行填充符号表。遍历兄弟节点完成。
其中的TypeProcess函数以树节点和树节点的声明类型为参数，建立符号表中的类型内部表示，对不同声明类型调用不同的构造类型内部表示函数（nameType（t），arrayType（t），recordType（t）），并将其地址返回给Ptr类型内部表示的地址。
对类型处理函数：
nameType（t）符号表中寻找已经定义的类型名，调用寻找表项地址函数返回找到的表项地址指针，若找到则检查标识符是否为类型标识符不是输出语义错误信息，否则将Ptr指向表项地址；若未找到则输出未找到的语义错误信息。
ArrayType（t）先检查数组的双下界是否合法否则输出不合法的语义错误信息，否则调用类型分析函数处理数组下标变量传Ptr0，元素类型变量传Ptr1，创建新的类型信息表填充大小（下标-上标加一乘元素类型的size即Ptr1->size），填充下标属性，元素属性上下界。
RecordType(t)新建记录类型节点，从语法树的儿子节点读取域信息，记录类型中的域名都是标识符的定义性出现需要记录其属性，填写域链指向的内容节点，在处理相同类型域元素时，需要都记录上，则新建域节点，填写该域节点的成员内容，指针右移，处理完同类型变量后取语法树兄弟节点处理其他类型的域变量。取最后一个域的偏移为整个记录的偏移，加上其size即为整个记录的size，将域链连入记录类型的body部分，返回Ptr。
而整型和字符类型在开始就初始化了其内部表示指针即为intPtr和charPtr。
变量声明语义处理函数varDecList（），当遇到变量标识符id时登记到符号表中检查重复性定义遇到类型时构造其内部表示：新建属性定义为varKind，调用内部表示函数，然后看是否是值参还是变参，变参属于间接变量，如果是VarPa时则定义其access为间接变量，记录参数的层数偏移，变参全局偏移Off++，否则其为值参为直接变量，值参偏移为当前偏移加上当前的类型大小，调用Enter函数登记属性和名字返回内部表示指针，同时检查重定义错误知道相同变量全部分析完，遍历兄弟节点取下一个类型变量声明。
过程声明语义处理函数procDecPart（），在当前层符号表中填写过程标识符属性，在新层符号表中填写形参标识符属性。首先处理过程头HeadProcess（），在当前符号表中填写函数表示服属性，在新层符号表中填写形参标识符属性，登记函数的符号表项，处理形参声明表，利用函数ParaDecList（），返回函数登记表项指针。其中的ParaDecList（）在新的符号表中登记所有形参表项，构造形参表项的地址表，当前语法树节点的第一个儿子不为空，则p指向第一个子结点，进入新的局部化区，调用函数变量声明处理函数，之后构造形参符号表并使其连接至符号表的param项返回形参符号表的头结点给param指针。
之后处理第二个函数声明的儿子节点，如果过程内部存在声明部分则处理声明部分，如果与发哦函数声明则跳出先填写noff和moff信息在处理函数声明的循环处理 ，过程活动记录的长度等于noff加上display表的长度，display表的长度等于过程所在层数加一，之后在处理函数声明部分遍历兄弟节点递归调用，最后执行执行体部分的语义处理函数Body（）；
     对于执行体函数Body（），如果当前节点为语句类型标志节点，则调用语句状态处理函数statement（），遍历语法树语句序列兄弟节点。
处理语句状态函数statement（）：针对不同的具体语句类型调用不同的语句处理函数，if：ifstatement（），while：whilestatement（），…………；否则输出语句类型语义错误信息。
对于if，while的语句处理因为后面紧跟表达式，所以对于表达式也有表达式处理分析函数Expr（）：中点检查运算分量类型是否相容，求表达式的类型等。如果是常量，则构造常量符号表，如果是变量，若没有儿子节点则在符号表中查找标识符，如果标识符不是变量输出语义错误信息，否则返回变量内部类型指针，如果是参数形式则返回间接边来那个，否则标识符未声明，如果有儿子节点，即如Var=Var0[E]类型，如果节点的表达式属性的变量类型为数组成员则调用数组变量下标分析函数arrayVar（）检查var0是否为数组类型，E是否和数组的下表变量类型匹配：查找节点的名字在符号表中，使得对应符号表地址为返回的表项地址，若未声明则直接输出语义错误信息，否则声明了var0不是变量打印语义错误信息，是变量检查是否是数组类型变量，如果不是输出错误信息，若是检查E的类型是否与下标类型相符，如果不符输出语义错误信息，返回空指针，否则返回元素下标表项指针。如若出现var=var0.id的情形则如果表达式的变量类型为域成员类型则调用记录变量域分析函数recordVar进行检查var0是否是记录类型变量，id是不是该记录类型中的域成员：在符号表中查找该标识符使得节点符号表指针指向相应的返回符号表地址，若没有则输出未声明语义错误，否则查看其是否为变量若不是则输出不是变量的语义错误，若是变量则看是否为记录类型的变量，如不是则输出错误信息，若是则检查id是否是合法域名，从域链中进行遍历查找，如果有则将返回指针指向相应域成员的类型表项，否则遍历查找，如果遍历完后别切没有找到表示符则输出不是域变量的错误信息，如果id是数组变量则将id作为数组下标处理函数的参数返回一个内部类型指针给Eptr。返回到Expr（）中如果表达式类型为Op，则递归调用儿子节点比比较两个儿子节点类型是否相容，如果不相容输出类型不相容语法错误信息，否则对表达式属性的操作符性型判断，如果是小于或等于则为条件表达式返回boolPtr，如果为加紧乘除则为算数表达式结果类型为intPtr，如果参数类型则返回直接变量。
接下来是对语句处理分析：
Ifstatement（），分析语法树三个儿子节点，调用表达式处理函数处理if后的表达式，即节点的第一个儿子节点，如果有的话处理条件表达式，如果结果类型不是布尔类型则输出条件表达式错误语义错误，否则对节点的第二个儿子节点处理，即then语句序列部分，递归调用statement（）遍历完兄弟节点，然后处理else语句部分遍历兄弟节点所有语句完成。
Whilestatement（），分析语法树两个儿子节点，调用表达式处理函数处理while后的表达式，即节点的第一个儿子节点，如果有的话处理表达式，如果结果类型不是布尔类型则输出条件表达式错误语义错误，否则对二儿子节点进行循环处理statement（）。
Inputstatemetn（），分析语法树节点检查read后的变量有无声明或是否为变量错误，用节点的名字检查整个符号表，如果没查到则未声明错误，如不是变量则不是变量错误
Writestatement（），分析输出表达式是否合法，如果表达式是bool类型则表达式不合法其他都合法。
Retrurnstatement（），分析返回语句是否在主程序中出现，即检查当前层数是否为0，为零这说明在主程序中有返回语句报错。
Assignment（）检查赋值号两端分量的类型是否相容，令child1和child2分别指向当前节点的第一和第二个儿子节点，第一个儿子节点是被赋值的标识符，如果该标识符节点没有儿子节点即其不是域或数组，则在符号表中查找该标识符，如果未找到输出语义错误，否则看id是否是变量，如果不是变量输出语义错误，否则令新的内部类型指针指向符号表项的内部类型指针，child1的符号表指向相应的符号表指针地址。如果是数组或域类型，则分别调用数组下标处理函数和域处理函数将返回的内部类型指针赋值给内部类型指针pp，如果第一个变量合法则检查当前当前节点的类型是否同时为语句类型和赋值类型，如果是则检查复制好两侧类型是否等价，需要使得赋值号右侧调用表达式处理函数返回内部类型指针送p如果p和pp类型不相同则两侧表达式不是同一类型语义错误。否则正确。
Callstatement（），首先检查符号表求出其函数属性中的参数部分，用其检查形参和实参之间的对应关系是否正确。首先对结点的第一个儿子节点查看整个符号表看是否声明，令儿子节点的符号表地址指向返回的符号表地址，如果未找到，则输出未声明错误，否则看函数名的种类是否为函数类型，不是则输出错误，否则查看形式参数和实在参数是否匹配，令p指向第二个儿子节点即第一个参数，让paramP指向形参符号表的表头，对形参符号表和语法树节点上的参数兄弟节点依次遍历，令内部类型指针指向实参，如果形参参数类型为间接变量并且实参类型为直接变量则输出参数种类不匹配的语义错误信息，否则如果形参的参数类型和实参的参数类型不相同则输出参数类型不匹配的语义错误信息。因为在兄弟节点指向下一个的时候形参表指针也往后以一个，当最终如果有一个不为空则说明形参和实参的个数不一样输出参数个数不同的语义错误信息。
这样语法树节点全部遍历完成，返回analyze（）语义分析总函数，如果当前的层数不是-1则撤销符号表，如果没有错误则输出正确信息，有的话在分析的时候就已经输出了。语义分析完成
五、主函数
主函数是要求用户输入源程序文件名，先调用词法分析程序，然后输出提示框根据用户选择的不同进行不同功能的输出，直到用户输入0退出程序为止。
当输入为1的话，调用打印Token序列的函数printTokenlist（）进行Token序列的输出，输入为2的话调用parse（）函数利用递归下降语法分析主函数生成语法树返回语法树的根节点，打印语法树最后释放整棵树，输入为3的话与2相同只不过是利用LL1分析方法进行语法分析，输入为4的话进行语义分析，新生成语法树parse（），然后调用语义分析总函数analyze（root）进行语义检查如果有错误则输出错误信息否则无措，进行是否打印符号表的用户提示按1是打印在语义分析过程中形成的符号表，否则不打印，按0则程序退出。
     
   




程序界面及运行截图










源程序核心代码















